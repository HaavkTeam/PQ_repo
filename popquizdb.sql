/*
 Navicat Premium Data Transfer

 Source Server         : 111
 Source Server Type    : MySQL
 Source Server Version : 80037 (8.0.37)
 Source Host           : localhost:3306
 Source Schema         : popquiz

 Target Server Type    : MySQL
 Target Server Version : 80037 (8.0.37)
 File Encoding         : 65001

 Date: 26/07/2025 00:32:46
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for answerdata
-- ----------------------------
DROP TABLE IF EXISTS `answerdata`;
CREATE TABLE `answerdata`  (
  `questionId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `userId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `selection` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `isCorrect` int NOT NULL
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of answerdata
-- ----------------------------
INSERT INTO `answerdata` VALUES ('12d23312ds1', '3333', 'A', 1);
INSERT INTO `answerdata` VALUES ('Q_12f1b5f0', '3333', 'A', 0);
INSERT INTO `answerdata` VALUES ('Q_1d8c3003', '1111', 'A', 0);
INSERT INTO `answerdata` VALUES ('Q_2c1c30d6', '1111', 'B', 1);
INSERT INTO `answerdata` VALUES ('Q_59cd7d87', '1111', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_48648cc7', '2222', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_79b6c537', '2222', 'C', 1);
INSERT INTO `answerdata` VALUES ('Q_48648cc7', '1111', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_79b6c537', '1111', 'C', 1);
INSERT INTO `answerdata` VALUES ('Q_48648cc7', '3333', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_2a1865b6', '53wmudqy', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_8ade1445', '53wmudqy', 'C', 1);
INSERT INTO `answerdata` VALUES ('Q_0c8c251c', '53wmudqy', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_1c88c683', '53wmudqy', 'A', 0);
INSERT INTO `answerdata` VALUES ('Q_284b56f5', '53wmudqy', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_b0ff726c', '53wmudqy', 'B', 1);
INSERT INTO `answerdata` VALUES ('Q_b185051a', '53wmudqy', 'C', 1);
INSERT INTO `answerdata` VALUES ('Q_22d9d7bc', '53wmudqy', 'B', 1);
INSERT INTO `answerdata` VALUES ('Q_307cc854', '53wmudqy', 'A', 0);
INSERT INTO `answerdata` VALUES ('Q_5dac4cd5', '53wmudqy', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_d5bb614b', '53wmudqy', 'C', 1);
INSERT INTO `answerdata` VALUES ('Q_e246e161', '53wmudqy', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_38cac3f1', '53wmudqy', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_b40586ce', '53wmudqy', 'B', 1);
INSERT INTO `answerdata` VALUES ('Q_d464e5c4', '53wmudqy', 'B', 0);
INSERT INTO `answerdata` VALUES ('Q_de9df114', '53wmudqy', 'C', 0);
INSERT INTO `answerdata` VALUES ('Q_fc82a38a', '53wmudqy', 'B', 0);

-- ----------------------------
-- Table structure for commenttable
-- ----------------------------
DROP TABLE IF EXISTS `commenttable`;
CREATE TABLE `commenttable`  (
  `commentId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `questionId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `publisher` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `replyId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `time` datetime NOT NULL,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`commentId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of commenttable
-- ----------------------------
INSERT INTO `commenttable` VALUES ('0', '00', '00', '0', '2025-07-16 22:15:55', '这是系统顶级评论');
INSERT INTO `commenttable` VALUES ('1', '12', 'wede2', '0', '2025-07-15 22:39:14', '哈哈');
INSERT INTO `commenttable` VALUES ('17l59a2n', 'Q_8ade1445', '53wmudqy', '0', '2025-07-25 21:59:16', '不对吧');
INSERT INTO `commenttable` VALUES ('2', '12', 'wede2', '1', '2025-07-17 22:39:28', '哈哈');
INSERT INTO `commenttable` VALUES ('3', '12', 'wede2', '2', '2025-07-15 22:39:47', '哈哈');
INSERT INTO `commenttable` VALUES ('4', '12', 'wede2', '1', '2025-07-15 22:39:57', '哈哈');
INSERT INTO `commenttable` VALUES ('41s56qkk', 'Q_22d9d7bc', '53wmudqy', '0', '2025-07-25 23:03:26', '不太对');
INSERT INTO `commenttable` VALUES ('4487m77s', 'Q_48648cc7', '1111', '0', '2025-07-25 16:55:10', 'sad');
INSERT INTO `commenttable` VALUES ('5', '12', 'wede2', '0', '2025-08-13 22:40:17', '哈哈');
INSERT INTO `commenttable` VALUES ('dmc576f3', 'Q_38cac3f1', '53wmudqy', '0', '2025-07-25 23:21:37', '不太对');
INSERT INTO `commenttable` VALUES ('e91jh4vj', 'Q_0c8c251c', '53wmudqy', '0', '2025-07-25 22:49:00', '不太正确');
INSERT INTO `commenttable` VALUES ('oalid4v6', 'Q_48648cc7', '1111', '4487m77s', '2025-07-25 16:55:34', '66');

-- ----------------------------
-- Table structure for filetable
-- ----------------------------
DROP TABLE IF EXISTS `filetable`;
CREATE TABLE `filetable`  (
  `fileId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `format` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `speechId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`fileId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of filetable
-- ----------------------------
INSERT INTO `filetable` VALUES ('C_15d2f610', 'pdf', '链表是动态线性结构，由节点（数据域+指针）串成，无需预分配空间，按需申请释放，空\n间利用率高。常见形态：单链表、带头单链表、双向链表、循环链表。插入删除O(1)，仅改\n指针；随机访问O(n)，须顺序遍历。可轻松实现栈、队列、哈希桶、邻接表、LRU缓存。注\n意哨兵节点简化边界、及时释放内存防泄漏、避免空指针与环。高级变种：跳表（多层索引\n加速搜索）、无锁链表（CAS实现并发）。对比数组：链表增删快、缓存命中率低；数组支持\n随机访问、可能浪费或扩容复制。', '321fwe21312');
INSERT INTO `filetable` VALUES ('C_1c4192b6', 'pptx', '幻灯片 1:\n软件体系结构\n第2章 软件的生命周期\n\n赵庆玲\n南京理工大学计算机科学与工程学院\nada_zhao@njust.edu.cn\n\n幻灯片 2:\n1、引言\n(1)什么是软件工程\n定义1：软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，这就是软件工程。\n定义2：软件工程是研究和应用如何以系统性的、规范化的、可定量的方法去开发、操纵和维护软件、即把工程应用到软件上。\n(2)什么是软件生命期\n定义3：软件生命期是指软件产品从考虑其概念开始，到该软件产品不再能使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段以及交付使用阶段、运行阶段和维护阶段。有时还有退役阶段。这些阶段可以有重复，执行时也可以有迭代。     \n\n幻灯片 3:\n(3)什么是软件开发生命期\n定义4：软件开发生命期是指软件产品从考虑其概念开始到该软件产品交付使用使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段，以及交付阶段。这些阶段可以有重叠，执行时也可以有迭代。\n(4)什么是软件开发过程  \n定义5：把用户的要求转变成软件产品的过程叫做软件开发过程。此过程包括对用户的要求进行分析，解释成软件需求，把需求变换成设计，把设计用代码来实现，测试该代码，有时还要进行代码安装和把软件交付运行使用。注意：这些活动可以重叠，执行时也可以有迭代。\n定义6：进行一组有组织的活动以把用户的要求转化成软件产品。 \n\n幻灯片 4:\n2、软件开发模型的发展\n在整个软件开发的发展过程中，为了要从宏观上管理软件的开发和维护，就必须对软件的发展过程有总体的认识和描述，即要对软件过程建模。几十年来，软件开发生命周期模型的的发展有了很大变化，提出了一系列的模型以适应软件开发发展的需要。在这里我们提出以下一些主要的软件开发模型：\n1．编码—修正模型(code and fix model)  \n\n幻灯片 5:\n2、软件开发模型的发展\n弊端：\n首先，代码缺少统一规划，低估了设计的重要性，使得代码结构随着修改次数的增加变得越来越坏。以至错误越来越难改，甚至无法改。\n第二，即使有的软件设计得很好，但往往其结果并非用户所需要的。造成软件开发的风险非常大。这主要是因为没有重视需求而造成的。\n第三，由于对测试、维护修改方面考虑不周，使得代码的维护修改非常困难。\n所以，当开发的软件规模不断扩大时，这种开发模型就会引起严重的后果，必须加以改进。 \n\n幻灯片 6:\n2、软件开发模型的发展\n2．瀑布模型(waterfall model)\n由于吸取软件开发早期的教训，人们开始将软件开发视为工程来管理。类似其他工程的管理，软件开发也具有一定的工序。于是，“软件生命周期”这一概念真正被提了出来，并将软件生命周期划分成了：制定计划、需求分析和定义、软件设计、程序编写、软件测试、运行和维护这六个步骤。\n在这一基础上，Winston W. Royce在1970年提出了著名的“瀑布模型”。瀑布模型规定了包括上述六个工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，并试图解决编码—修正模型所带来的问题。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下，呈线性因式。实际情况中，每项开发活动大部分具有以下特点： \n\n幻灯片 7:\n2、软件开发模型的发展\n(1)从上一项开发活动接受该项活动的工作对象，作为输入。\n(2)利用这一输入，实施该项活动应完成的工作内容。\n(3)给出该项活动的工作成果，作为输出传给下一项开发活动。\n(4)对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动，如下图中的向下箭头所表示；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。 \n\n幻灯片 8:\n2、软件开发模型的发展\n\n幻灯片 9:\n2、软件开发模型的发展\n但是瀑布模型同样存在一些问题：\n首先，阶段和阶段划分完全固定，阶段间产生大量的文档，极大地增加了工作量。\n第二，由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。\n第三，前面未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会造成更不理想的后果。\n为此，常常在需求阶段或设计阶段平行地进行几次快速原型，来消除风险和不确定性。该模型长期以来已成为美国政府或军方的软件项目的主要标准。但是瀑布模型的一些根本性缺陷推动着人们继续探索新的模型。相当一部分人认为应考虑采用形式化方法的转换模型以减少人为的错误。 \n\n幻灯片 10:\n2、软件开发模型的发展\n3．转换模型\n其主要思想是用形式化的方法自动生成程序。主要步骤为：\n(1)采用形式化的规格说明书。(2)通过自动系统自动地变换成代码。(3)必要时做一些优化，改进性能。(4)交付用户使用。(5)根据使用的经验来调整形式化的规格说明书。返回(1)重复整个过程。\n转换模型的优点是解决了代码结构经多次修改而变坏的问题；减少了许多中间步骤，如设计、编码、测试等等。但是，转换模型仍有较大局限，表现在：\n(1)自动转换在实际上仅适用于规模很小产品；或某些非常特定领域的产品。(2)用户容易无计划地修改，是否能保证向正确、优化及改进方向发展呢?\n(3)需要非常庞大的支持体系。特别考虑到当前技术飞速发展的特点，这种进行自动转换的系统中应该包含和维护的知识数量呈爆炸性(商品化的软件，硬件平台知识)。 \n\n幻灯片 11:\n4．平行瀑布模型\n现在考虑对瀑布模型的进一步改进。对瀑布模型的各个阶段之间转换时，不一定要求完全按顺序进行。而是可以适当并行开展各阶段的开发工作。在上一个阶段尚未完全结束前，就可开设后一阶段的开发工作。例如，在需求分析完成60％时，就可开始进行这60％的已完成分析部分的设计工作。同时并行进行余留的40％的需求分析。根据不同情况可有不同的并行度。例如：\n(1)用户想法不稳定，比方说，每天变换想法，要求不太清楚的话，则增加并行度。\n(2)短期显示成果的压力大，则可增加并行度。例如，在某种场合，在某些人的眼光中，按期完成70％的测试后的程序，比做完100％的设计，但无一行代码的印象好得多。\n(3)如果可靠性要求高；要求各方面控制和配合很严格；资源及预算严密；技术错误的后果严重时，则需减少并行度。\n一般，对小系统关系不大，但对于大型系统的开发，则需根据实际情况认真分析考虑，难以用一个固定衡量标准。 \n\n幻灯片 12:\n5．演进式开发模型\n由于在项目开发的初期，人们对软件需求的认识常常不够清晰，因而使得在进行项目开发时，难于做到一次开发成功。出现返工，再一次开发常常在所难免。有人说，目标只在于探索可行性，弄清软件需求；第二次则在第一次开发的基础上获得较为满意的软件产品。通常把第一次得到的试验性产品称为“原型”。如果系统十分复杂，就可能要开发多次，每次只开发系统的一部分功能。每次在前一次的基础上，进行改进并扩大性能、功能，直到达到要求。显然，这种依靠演进方式进行开发的演化模型在克服瀑布模型的缺点，减少由于软件需求不明确而给工作带来风险方面，确有显著的效果。这种开发模型的问题是不要把演进式开发模型实际执行成原始的编码—修正模型。 \n\n幻灯片 13:\n6．螺旋模型\n70年代和80年代，硬件技术不断提高，软件系统也不断庞大。而当我们面对一个复杂的大型软件系统时，用“瀑布模型”还是“演化模型”都难于有效地完成项目。于是，\nBarry Boehm在1988年正式发表了软件系统开发的“螺旋模型”。螺旋模型将瀑布模型和演化模型等结合起来，并且强调了其他模型均忽略了的风险分析。这种模型特别适用于庞大而复杂的系统、高风险的系统。对于这些系统，风险是软件开发不可忽视的、潜在的不利因素。它可能在不同程度上损害软件开发过程或软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。\n螺旋模型如图所示。 \n\n幻灯片 15:\n螺旋模型更适合于大型软件的开发，应该说它对于具有高度风险的大型复杂软件系统的开发是最为实际的方法。螺旋模型实际上是吸收和综合了过去各种软件开发模型。每种模型都可用特定情况的螺旋模型来表示。但它强调风险分析，吸收了软件工程“演化”的概念，使得开发人员和客户对每个演化层出现的风险有所了解，继而做出应有的反应。但是，还不能说螺旋模型绝对比其他模型优越。首先，要求许多客户接受和相信演化方法并不容易。其次，需要具有相当丰富的风险评估经验和专门知识，才能使用这个模型。对于风险较大的项目来说，在这类项目开发中，如果未能够即时发现风险，势必会造成重大损失。采用螺旋模型显然是很合适的。 \n\n幻灯片 16:\n各种模型的比较\n每个软件开发组织应该选择适合于该组织的软件开发模型，并且应该随着当前正在开发的特定产品特性而变化，以减小所选模型的缺点，充分利用其优点。', 'ded');
INSERT INTO `filetable` VALUES ('C_26590eb1', 'pptx', '幻灯片 1:\n软件体系结构\n第2章 软件的生命周期\n\n赵庆玲\n南京理工大学计算机科学与工程学院\nada_zhao@njust.edu.cn\n\n幻灯片 2:\n1、引言\n(1)什么是软件工程\n定义1：软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，这就是软件工程。\n定义2：软件工程是研究和应用如何以系统性的、规范化的、可定量的方法去开发、操纵和维护软件、即把工程应用到软件上。\n(2)什么是软件生命期\n定义3：软件生命期是指软件产品从考虑其概念开始，到该软件产品不再能使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段以及交付使用阶段、运行阶段和维护阶段。有时还有退役阶段。这些阶段可以有重复，执行时也可以有迭代。     \n\n幻灯片 3:\n(3)什么是软件开发生命期\n定义4：软件开发生命期是指软件产品从考虑其概念开始到该软件产品交付使用使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段，以及交付阶段。这些阶段可以有重叠，执行时也可以有迭代。\n(4)什么是软件开发过程  \n定义5：把用户的要求转变成软件产品的过程叫做软件开发过程。此过程包括对用户的要求进行分析，解释成软件需求，把需求变换成设计，把设计用代码来实现，测试该代码，有时还要进行代码安装和把软件交付运行使用。注意：这些活动可以重叠，执行时也可以有迭代。\n定义6：进行一组有组织的活动以把用户的要求转化成软件产品。 \n\n幻灯片 4:\n2、软件开发模型的发展\n在整个软件开发的发展过程中，为了要从宏观上管理软件的开发和维护，就必须对软件的发展过程有总体的认识和描述，即要对软件过程建模。几十年来，软件开发生命周期模型的的发展有了很大变化，提出了一系列的模型以适应软件开发发展的需要。在这里我们提出以下一些主要的软件开发模型：\n1．编码—修正模型(code and fix model)  \n\n幻灯片 5:\n2、软件开发模型的发展\n弊端：\n首先，代码缺少统一规划，低估了设计的重要性，使得代码结构随着修改次数的增加变得越来越坏。以至错误越来越难改，甚至无法改。\n第二，即使有的软件设计得很好，但往往其结果并非用户所需要的。造成软件开发的风险非常大。这主要是因为没有重视需求而造成的。\n第三，由于对测试、维护修改方面考虑不周，使得代码的维护修改非常困难。\n所以，当开发的软件规模不断扩大时，这种开发模型就会引起严重的后果，必须加以改进。 \n\n幻灯片 6:\n2、软件开发模型的发展\n2．瀑布模型(waterfall model)\n由于吸取软件开发早期的教训，人们开始将软件开发视为工程来管理。类似其他工程的管理，软件开发也具有一定的工序。于是，“软件生命周期”这一概念真正被提了出来，并将软件生命周期划分成了：制定计划、需求分析和定义、软件设计、程序编写、软件测试、运行和维护这六个步骤。\n在这一基础上，Winston W. Royce在1970年提出了著名的“瀑布模型”。瀑布模型规定了包括上述六个工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，并试图解决编码—修正模型所带来的问题。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下，呈线性因式。实际情况中，每项开发活动大部分具有以下特点： \n\n幻灯片 7:\n2、软件开发模型的发展\n(1)从上一项开发活动接受该项活动的工作对象，作为输入。\n(2)利用这一输入，实施该项活动应完成的工作内容。\n(3)给出该项活动的工作成果，作为输出传给下一项开发活动。\n(4)对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动，如下图中的向下箭头所表示；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。 \n\n幻灯片 8:\n2、软件开发模型的发展\n\n幻灯片 9:\n2、软件开发模型的发展\n但是瀑布模型同样存在一些问题：\n首先，阶段和阶段划分完全固定，阶段间产生大量的文档，极大地增加了工作量。\n第二，由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。\n第三，前面未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会造成更不理想的后果。\n为此，常常在需求阶段或设计阶段平行地进行几次快速原型，来消除风险和不确定性。该模型长期以来已成为美国政府或军方的软件项目的主要标准。但是瀑布模型的一些根本性缺陷推动着人们继续探索新的模型。相当一部分人认为应考虑采用形式化方法的转换模型以减少人为的错误。 \n\n幻灯片 10:\n2、软件开发模型的发展\n3．转换模型\n其主要思想是用形式化的方法自动生成程序。主要步骤为：\n(1)采用形式化的规格说明书。(2)通过自动系统自动地变换成代码。(3)必要时做一些优化，改进性能。(4)交付用户使用。(5)根据使用的经验来调整形式化的规格说明书。返回(1)重复整个过程。\n转换模型的优点是解决了代码结构经多次修改而变坏的问题；减少了许多中间步骤，如设计、编码、测试等等。但是，转换模型仍有较大局限，表现在：\n(1)自动转换在实际上仅适用于规模很小产品；或某些非常特定领域的产品。(2)用户容易无计划地修改，是否能保证向正确、优化及改进方向发展呢?\n(3)需要非常庞大的支持体系。特别考虑到当前技术飞速发展的特点，这种进行自动转换的系统中应该包含和维护的知识数量呈爆炸性(商品化的软件，硬件平台知识)。 \n\n幻灯片 11:\n4．平行瀑布模型\n现在考虑对瀑布模型的进一步改进。对瀑布模型的各个阶段之间转换时，不一定要求完全按顺序进行。而是可以适当并行开展各阶段的开发工作。在上一个阶段尚未完全结束前，就可开设后一阶段的开发工作。例如，在需求分析完成60％时，就可开始进行这60％的已完成分析部分的设计工作。同时并行进行余留的40％的需求分析。根据不同情况可有不同的并行度。例如：\n(1)用户想法不稳定，比方说，每天变换想法，要求不太清楚的话，则增加并行度。\n(2)短期显示成果的压力大，则可增加并行度。例如，在某种场合，在某些人的眼光中，按期完成70％的测试后的程序，比做完100％的设计，但无一行代码的印象好得多。\n(3)如果可靠性要求高；要求各方面控制和配合很严格；资源及预算严密；技术错误的后果严重时，则需减少并行度。\n一般，对小系统关系不大，但对于大型系统的开发，则需根据实际情况认真分析考虑，难以用一个固定衡量标准。 \n\n幻灯片 12:\n5．演进式开发模型\n由于在项目开发的初期，人们对软件需求的认识常常不够清晰，因而使得在进行项目开发时，难于做到一次开发成功。出现返工，再一次开发常常在所难免。有人说，目标只在于探索可行性，弄清软件需求；第二次则在第一次开发的基础上获得较为满意的软件产品。通常把第一次得到的试验性产品称为“原型”。如果系统十分复杂，就可能要开发多次，每次只开发系统的一部分功能。每次在前一次的基础上，进行改进并扩大性能、功能，直到达到要求。显然，这种依靠演进方式进行开发的演化模型在克服瀑布模型的缺点，减少由于软件需求不明确而给工作带来风险方面，确有显著的效果。这种开发模型的问题是不要把演进式开发模型实际执行成原始的编码—修正模型。 \n\n幻灯片 13:\n6．螺旋模型\n70年代和80年代，硬件技术不断提高，软件系统也不断庞大。而当我们面对一个复杂的大型软件系统时，用“瀑布模型”还是“演化模型”都难于有效地完成项目。于是，\nBarry Boehm在1988年正式发表了软件系统开发的“螺旋模型”。螺旋模型将瀑布模型和演化模型等结合起来，并且强调了其他模型均忽略了的风险分析。这种模型特别适用于庞大而复杂的系统、高风险的系统。对于这些系统，风险是软件开发不可忽视的、潜在的不利因素。它可能在不同程度上损害软件开发过程或软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。\n螺旋模型如图所示。 \n\n幻灯片 15:\n螺旋模型更适合于大型软件的开发，应该说它对于具有高度风险的大型复杂软件系统的开发是最为实际的方法。螺旋模型实际上是吸收和综合了过去各种软件开发模型。每种模型都可用特定情况的螺旋模型来表示。但它强调风险分析，吸收了软件工程“演化”的概念，使得开发人员和客户对每个演化层出现的风险有所了解，继而做出应有的反应。但是，还不能说螺旋模型绝对比其他模型优越。首先，要求许多客户接受和相信演化方法并不容易。其次，需要具有相当丰富的风险评估经验和专门知识，才能使用这个模型。对于风险较大的项目来说，在这类项目开发中，如果未能够即时发现风险，势必会造成重大损失。采用螺旋模型显然是很合适的。 \n\n幻灯片 16:\n各种模型的比较\n每个软件开发组织应该选择适合于该组织的软件开发模型，并且应该随着当前正在开发的特定产品特性而变化，以减小所选模型的缺点，充分利用其优点。', '3123213');
INSERT INTO `filetable` VALUES ('C_29f93960', 'pdf', '链表是动态线性结构，由节点（数据域+指针）串成，无需预分配空间，按需申请释放，空\n间利用率高。常见形态：单链表、带头单链表、双向链表、循环链表。插入删除O(1)，仅改\n指针；随机访问O(n)，须顺序遍历。可轻松实现栈、队列、哈希桶、邻接表、LRU缓存。注\n意哨兵节点简化边界、及时释放内存防泄漏、避免空指针与环。高级变种：跳表（多层索引\n加速搜索）、无锁链表（CAS实现并发）。对比数组：链表增删快、缓存命中率低；数组支持\n随机访问、可能浪费或扩容复制。', '321fwe21312');
INSERT INTO `filetable` VALUES ('C_2ec43690', 'docx', '在计算机组成原理中，指令流水线是提高处理器吞吐率的核心技术。其基本思想是将一条指令的执行过程划分为若干个子阶段，每个阶段由专用硬件并行处理，使得多条指令重叠执行。以经典的五级流水线为例，包含取指（IF）、译码（ID）、执行（EX）、访存（MEM）和写回（WB）五个阶段。当第一条指令进入译码阶段时，第二条指令可同时进入取指阶段，理想情况下每个时钟周期都能完成一条指令，吞吐率提升近5倍。然而，流水线面临三类主要冲突：结构冲突（资源争用，如两条指令同时访问同一存储器）、数据冲突（后续指令依赖前序指令结果，例如RAW真数据相关需通过转发或停顿解决）和控制冲突（分支指令改变PC值导致流水线刷新，可通过分支预测或延迟槽技术缓解）。现代CPU采用动态流水线调度（如Tomasulo算法）和超标量技术（每个周期发射多条指令）进一步挖掘并行性，但伴随的流水线深度增加（如14级以上的Pentium 4）会导致分支预测失败惩罚加重，这体现了计算性能与复杂度的权衡。', 'z97w2i7q');
INSERT INTO `filetable` VALUES ('C_32cd7a96', 'pptx', '幻灯片 1:\n软件体系结构\n第2章 软件的生命周期\n\n赵庆玲\n南京理工大学计算机科学与工程学院\nada_zhao@njust.edu.cn\n\n幻灯片 2:\n1、引言\n(1)什么是软件工程\n定义1：软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，这就是软件工程。\n定义2：软件工程是研究和应用如何以系统性的、规范化的、可定量的方法去开发、操纵和维护软件、即把工程应用到软件上。\n(2)什么是软件生命期\n定义3：软件生命期是指软件产品从考虑其概念开始，到该软件产品不再能使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段以及交付使用阶段、运行阶段和维护阶段。有时还有退役阶段。这些阶段可以有重复，执行时也可以有迭代。     \n\n幻灯片 3:\n(3)什么是软件开发生命期\n定义4：软件开发生命期是指软件产品从考虑其概念开始到该软件产品交付使用使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段，以及交付阶段。这些阶段可以有重叠，执行时也可以有迭代。\n(4)什么是软件开发过程  \n定义5：把用户的要求转变成软件产品的过程叫做软件开发过程。此过程包括对用户的要求进行分析，解释成软件需求，把需求变换成设计，把设计用代码来实现，测试该代码，有时还要进行代码安装和把软件交付运行使用。注意：这些活动可以重叠，执行时也可以有迭代。\n定义6：进行一组有组织的活动以把用户的要求转化成软件产品。 \n\n幻灯片 4:\n2、软件开发模型的发展\n在整个软件开发的发展过程中，为了要从宏观上管理软件的开发和维护，就必须对软件的发展过程有总体的认识和描述，即要对软件过程建模。几十年来，软件开发生命周期模型的的发展有了很大变化，提出了一系列的模型以适应软件开发发展的需要。在这里我们提出以下一些主要的软件开发模型：\n1．编码—修正模型(code and fix model)  \n\n幻灯片 5:\n2、软件开发模型的发展\n弊端：\n首先，代码缺少统一规划，低估了设计的重要性，使得代码结构随着修改次数的增加变得越来越坏。以至错误越来越难改，甚至无法改。\n第二，即使有的软件设计得很好，但往往其结果并非用户所需要的。造成软件开发的风险非常大。这主要是因为没有重视需求而造成的。\n第三，由于对测试、维护修改方面考虑不周，使得代码的维护修改非常困难。\n所以，当开发的软件规模不断扩大时，这种开发模型就会引起严重的后果，必须加以改进。 \n\n幻灯片 6:\n2、软件开发模型的发展\n2．瀑布模型(waterfall model)\n由于吸取软件开发早期的教训，人们开始将软件开发视为工程来管理。类似其他工程的管理，软件开发也具有一定的工序。于是，“软件生命周期”这一概念真正被提了出来，并将软件生命周期划分成了：制定计划、需求分析和定义、软件设计、程序编写、软件测试、运行和维护这六个步骤。\n在这一基础上，Winston W. Royce在1970年提出了著名的“瀑布模型”。瀑布模型规定了包括上述六个工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，并试图解决编码—修正模型所带来的问题。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下，呈线性因式。实际情况中，每项开发活动大部分具有以下特点： \n\n幻灯片 7:\n2、软件开发模型的发展\n(1)从上一项开发活动接受该项活动的工作对象，作为输入。\n(2)利用这一输入，实施该项活动应完成的工作内容。\n(3)给出该项活动的工作成果，作为输出传给下一项开发活动。\n(4)对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动，如下图中的向下箭头所表示；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。 \n\n幻灯片 8:\n2、软件开发模型的发展\n\n幻灯片 9:\n2、软件开发模型的发展\n但是瀑布模型同样存在一些问题：\n首先，阶段和阶段划分完全固定，阶段间产生大量的文档，极大地增加了工作量。\n第二，由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。\n第三，前面未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会造成更不理想的后果。\n为此，常常在需求阶段或设计阶段平行地进行几次快速原型，来消除风险和不确定性。该模型长期以来已成为美国政府或军方的软件项目的主要标准。但是瀑布模型的一些根本性缺陷推动着人们继续探索新的模型。相当一部分人认为应考虑采用形式化方法的转换模型以减少人为的错误。 \n\n幻灯片 10:\n2、软件开发模型的发展\n3．转换模型\n其主要思想是用形式化的方法自动生成程序。主要步骤为：\n(1)采用形式化的规格说明书。(2)通过自动系统自动地变换成代码。(3)必要时做一些优化，改进性能。(4)交付用户使用。(5)根据使用的经验来调整形式化的规格说明书。返回(1)重复整个过程。\n转换模型的优点是解决了代码结构经多次修改而变坏的问题；减少了许多中间步骤，如设计、编码、测试等等。但是，转换模型仍有较大局限，表现在：\n(1)自动转换在实际上仅适用于规模很小产品；或某些非常特定领域的产品。(2)用户容易无计划地修改，是否能保证向正确、优化及改进方向发展呢?\n(3)需要非常庞大的支持体系。特别考虑到当前技术飞速发展的特点，这种进行自动转换的系统中应该包含和维护的知识数量呈爆炸性(商品化的软件，硬件平台知识)。 \n\n幻灯片 11:\n4．平行瀑布模型\n现在考虑对瀑布模型的进一步改进。对瀑布模型的各个阶段之间转换时，不一定要求完全按顺序进行。而是可以适当并行开展各阶段的开发工作。在上一个阶段尚未完全结束前，就可开设后一阶段的开发工作。例如，在需求分析完成60％时，就可开始进行这60％的已完成分析部分的设计工作。同时并行进行余留的40％的需求分析。根据不同情况可有不同的并行度。例如：\n(1)用户想法不稳定，比方说，每天变换想法，要求不太清楚的话，则增加并行度。\n(2)短期显示成果的压力大，则可增加并行度。例如，在某种场合，在某些人的眼光中，按期完成70％的测试后的程序，比做完100％的设计，但无一行代码的印象好得多。\n(3)如果可靠性要求高；要求各方面控制和配合很严格；资源及预算严密；技术错误的后果严重时，则需减少并行度。\n一般，对小系统关系不大，但对于大型系统的开发，则需根据实际情况认真分析考虑，难以用一个固定衡量标准。 \n\n幻灯片 12:\n5．演进式开发模型\n由于在项目开发的初期，人们对软件需求的认识常常不够清晰，因而使得在进行项目开发时，难于做到一次开发成功。出现返工，再一次开发常常在所难免。有人说，目标只在于探索可行性，弄清软件需求；第二次则在第一次开发的基础上获得较为满意的软件产品。通常把第一次得到的试验性产品称为“原型”。如果系统十分复杂，就可能要开发多次，每次只开发系统的一部分功能。每次在前一次的基础上，进行改进并扩大性能、功能，直到达到要求。显然，这种依靠演进方式进行开发的演化模型在克服瀑布模型的缺点，减少由于软件需求不明确而给工作带来风险方面，确有显著的效果。这种开发模型的问题是不要把演进式开发模型实际执行成原始的编码—修正模型。 \n\n幻灯片 13:\n6．螺旋模型\n70年代和80年代，硬件技术不断提高，软件系统也不断庞大。而当我们面对一个复杂的大型软件系统时，用“瀑布模型”还是“演化模型”都难于有效地完成项目。于是，\nBarry Boehm在1988年正式发表了软件系统开发的“螺旋模型”。螺旋模型将瀑布模型和演化模型等结合起来，并且强调了其他模型均忽略了的风险分析。这种模型特别适用于庞大而复杂的系统、高风险的系统。对于这些系统，风险是软件开发不可忽视的、潜在的不利因素。它可能在不同程度上损害软件开发过程或软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。\n螺旋模型如图所示。 \n\n幻灯片 15:\n螺旋模型更适合于大型软件的开发，应该说它对于具有高度风险的大型复杂软件系统的开发是最为实际的方法。螺旋模型实际上是吸收和综合了过去各种软件开发模型。每种模型都可用特定情况的螺旋模型来表示。但它强调风险分析，吸收了软件工程“演化”的概念，使得开发人员和客户对每个演化层出现的风险有所了解，继而做出应有的反应。但是，还不能说螺旋模型绝对比其他模型优越。首先，要求许多客户接受和相信演化方法并不容易。其次，需要具有相当丰富的风险评估经验和专门知识，才能使用这个模型。对于风险较大的项目来说，在这类项目开发中，如果未能够即时发现风险，势必会造成重大损失。采用螺旋模型显然是很合适的。 \n\n幻灯片 16:\n各种模型的比较\n每个软件开发组织应该选择适合于该组织的软件开发模型，并且应该随着当前正在开发的特定产品特性而变化，以减小所选模型的缺点，充分利用其优点。', '3123213');
INSERT INTO `filetable` VALUES ('C_5301bd94', 'docx', '在计算机组成原理中，指令流水线是提高处理器吞吐率的核心技术。其基本思想是将一条指令的执行过程划分为若干个子阶段，每个阶段由专用硬件并行处理，使得多条指令重叠执行。以经典的五级流水线为例，包含取指（IF）、译码（ID）、执行（EX）、访存（MEM）和写回（WB）五个阶段。当第一条指令进入译码阶段时，第二条指令可同时进入取指阶段，理想情况下每个时钟周期都能完成一条指令，吞吐率提升近5倍。然而，流水线面临三类主要冲突：结构冲突（资源争用，如两条指令同时访问同一存储器）、数据冲突（后续指令依赖前序指令结果，例如RAW真数据相关需通过转发或停顿解决）和控制冲突（分支指令改变PC值导致流水线刷新，可通过分支预测或延迟槽技术缓解）。现代CPU采用动态流水线调度（如Tomasulo算法）和超标量技术（每个周期发射多条指令）进一步挖掘并行性，但伴随的流水线深度增加（如14级以上的Pentium 4）会导致分支预测失败惩罚加重，这体现了计算性能与复杂度的权衡。', 'gat222l9');
INSERT INTO `filetable` VALUES ('C_64def05d', 'docx', '在计算机组成原理中，指令流水线是提高处理器吞吐率的核心技术。其基本思想是将一条指令的执行过程划分为若干个子阶段，每个阶段由专用硬件并行处理，使得多条指令重叠执行。以经典的五级流水线为例，包含取指（IF）、译码（ID）、执行（EX）、访存（MEM）和写回（WB）五个阶段。当第一条指令进入译码阶段时，第二条指令可同时进入取指阶段，理想情况下每个时钟周期都能完成一条指令，吞吐率提升近5倍。然而，流水线面临三类主要冲突：结构冲突（资源争用，如两条指令同时访问同一存储器）、数据冲突（后续指令依赖前序指令结果，例如RAW真数据相关需通过转发或停顿解决）和控制冲突（分支指令改变PC值导致流水线刷新，可通过分支预测或延迟槽技术缓解）。现代CPU采用动态流水线调度（如Tomasulo算法）和超标量技术（每个周期发射多条指令）进一步挖掘并行性，但伴随的流水线深度增加（如14级以上的Pentium 4）会导致分支预测失败惩罚加重，这体现了计算性能与复杂度的权衡。', 's4b6kld7');
INSERT INTO `filetable` VALUES ('C_7fef1ada', 'pptx', '幻灯片 1:\n软件体系结构\n第2章 软件的生命周期\n\n赵庆玲\n南京理工大学计算机科学与工程学院\nada_zhao@njust.edu.cn\n\n幻灯片 2:\n1、引言\n(1)什么是软件工程\n定义1：软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，这就是软件工程。\n定义2：软件工程是研究和应用如何以系统性的、规范化的、可定量的方法去开发、操纵和维护软件、即把工程应用到软件上。\n(2)什么是软件生命期\n定义3：软件生命期是指软件产品从考虑其概念开始，到该软件产品不再能使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段以及交付使用阶段、运行阶段和维护阶段。有时还有退役阶段。这些阶段可以有重复，执行时也可以有迭代。     \n\n幻灯片 3:\n(3)什么是软件开发生命期\n定义4：软件开发生命期是指软件产品从考虑其概念开始到该软件产品交付使用使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段，以及交付阶段。这些阶段可以有重叠，执行时也可以有迭代。\n(4)什么是软件开发过程  \n定义5：把用户的要求转变成软件产品的过程叫做软件开发过程。此过程包括对用户的要求进行分析，解释成软件需求，把需求变换成设计，把设计用代码来实现，测试该代码，有时还要进行代码安装和把软件交付运行使用。注意：这些活动可以重叠，执行时也可以有迭代。\n定义6：进行一组有组织的活动以把用户的要求转化成软件产品。 \n\n幻灯片 4:\n2、软件开发模型的发展\n在整个软件开发的发展过程中，为了要从宏观上管理软件的开发和维护，就必须对软件的发展过程有总体的认识和描述，即要对软件过程建模。几十年来，软件开发生命周期模型的的发展有了很大变化，提出了一系列的模型以适应软件开发发展的需要。在这里我们提出以下一些主要的软件开发模型：\n1．编码—修正模型(code and fix model)  \n\n幻灯片 5:\n2、软件开发模型的发展\n弊端：\n首先，代码缺少统一规划，低估了设计的重要性，使得代码结构随着修改次数的增加变得越来越坏。以至错误越来越难改，甚至无法改。\n第二，即使有的软件设计得很好，但往往其结果并非用户所需要的。造成软件开发的风险非常大。这主要是因为没有重视需求而造成的。\n第三，由于对测试、维护修改方面考虑不周，使得代码的维护修改非常困难。\n所以，当开发的软件规模不断扩大时，这种开发模型就会引起严重的后果，必须加以改进。 \n\n幻灯片 6:\n2、软件开发模型的发展\n2．瀑布模型(waterfall model)\n由于吸取软件开发早期的教训，人们开始将软件开发视为工程来管理。类似其他工程的管理，软件开发也具有一定的工序。于是，“软件生命周期”这一概念真正被提了出来，并将软件生命周期划分成了：制定计划、需求分析和定义、软件设计、程序编写、软件测试、运行和维护这六个步骤。\n在这一基础上，Winston W. Royce在1970年提出了著名的“瀑布模型”。瀑布模型规定了包括上述六个工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，并试图解决编码—修正模型所带来的问题。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下，呈线性因式。实际情况中，每项开发活动大部分具有以下特点： \n\n幻灯片 7:\n2、软件开发模型的发展\n(1)从上一项开发活动接受该项活动的工作对象，作为输入。\n(2)利用这一输入，实施该项活动应完成的工作内容。\n(3)给出该项活动的工作成果，作为输出传给下一项开发活动。\n(4)对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动，如下图中的向下箭头所表示；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。 \n\n幻灯片 8:\n2、软件开发模型的发展\n\n幻灯片 9:\n2、软件开发模型的发展\n但是瀑布模型同样存在一些问题：\n首先，阶段和阶段划分完全固定，阶段间产生大量的文档，极大地增加了工作量。\n第二，由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。\n第三，前面未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会造成更不理想的后果。\n为此，常常在需求阶段或设计阶段平行地进行几次快速原型，来消除风险和不确定性。该模型长期以来已成为美国政府或军方的软件项目的主要标准。但是瀑布模型的一些根本性缺陷推动着人们继续探索新的模型。相当一部分人认为应考虑采用形式化方法的转换模型以减少人为的错误。 \n\n幻灯片 10:\n2、软件开发模型的发展\n3．转换模型\n其主要思想是用形式化的方法自动生成程序。主要步骤为：\n(1)采用形式化的规格说明书。(2)通过自动系统自动地变换成代码。(3)必要时做一些优化，改进性能。(4)交付用户使用。(5)根据使用的经验来调整形式化的规格说明书。返回(1)重复整个过程。\n转换模型的优点是解决了代码结构经多次修改而变坏的问题；减少了许多中间步骤，如设计、编码、测试等等。但是，转换模型仍有较大局限，表现在：\n(1)自动转换在实际上仅适用于规模很小产品；或某些非常特定领域的产品。(2)用户容易无计划地修改，是否能保证向正确、优化及改进方向发展呢?\n(3)需要非常庞大的支持体系。特别考虑到当前技术飞速发展的特点，这种进行自动转换的系统中应该包含和维护的知识数量呈爆炸性(商品化的软件，硬件平台知识)。 \n\n幻灯片 11:\n4．平行瀑布模型\n现在考虑对瀑布模型的进一步改进。对瀑布模型的各个阶段之间转换时，不一定要求完全按顺序进行。而是可以适当并行开展各阶段的开发工作。在上一个阶段尚未完全结束前，就可开设后一阶段的开发工作。例如，在需求分析完成60％时，就可开始进行这60％的已完成分析部分的设计工作。同时并行进行余留的40％的需求分析。根据不同情况可有不同的并行度。例如：\n(1)用户想法不稳定，比方说，每天变换想法，要求不太清楚的话，则增加并行度。\n(2)短期显示成果的压力大，则可增加并行度。例如，在某种场合，在某些人的眼光中，按期完成70％的测试后的程序，比做完100％的设计，但无一行代码的印象好得多。\n(3)如果可靠性要求高；要求各方面控制和配合很严格；资源及预算严密；技术错误的后果严重时，则需减少并行度。\n一般，对小系统关系不大，但对于大型系统的开发，则需根据实际情况认真分析考虑，难以用一个固定衡量标准。 \n\n幻灯片 12:\n5．演进式开发模型\n由于在项目开发的初期，人们对软件需求的认识常常不够清晰，因而使得在进行项目开发时，难于做到一次开发成功。出现返工，再一次开发常常在所难免。有人说，目标只在于探索可行性，弄清软件需求；第二次则在第一次开发的基础上获得较为满意的软件产品。通常把第一次得到的试验性产品称为“原型”。如果系统十分复杂，就可能要开发多次，每次只开发系统的一部分功能。每次在前一次的基础上，进行改进并扩大性能、功能，直到达到要求。显然，这种依靠演进方式进行开发的演化模型在克服瀑布模型的缺点，减少由于软件需求不明确而给工作带来风险方面，确有显著的效果。这种开发模型的问题是不要把演进式开发模型实际执行成原始的编码—修正模型。 \n\n幻灯片 13:\n6．螺旋模型\n70年代和80年代，硬件技术不断提高，软件系统也不断庞大。而当我们面对一个复杂的大型软件系统时，用“瀑布模型”还是“演化模型”都难于有效地完成项目。于是，\nBarry Boehm在1988年正式发表了软件系统开发的“螺旋模型”。螺旋模型将瀑布模型和演化模型等结合起来，并且强调了其他模型均忽略了的风险分析。这种模型特别适用于庞大而复杂的系统、高风险的系统。对于这些系统，风险是软件开发不可忽视的、潜在的不利因素。它可能在不同程度上损害软件开发过程或软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。\n螺旋模型如图所示。 \n\n幻灯片 15:\n螺旋模型更适合于大型软件的开发，应该说它对于具有高度风险的大型复杂软件系统的开发是最为实际的方法。螺旋模型实际上是吸收和综合了过去各种软件开发模型。每种模型都可用特定情况的螺旋模型来表示。但它强调风险分析，吸收了软件工程“演化”的概念，使得开发人员和客户对每个演化层出现的风险有所了解，继而做出应有的反应。但是，还不能说螺旋模型绝对比其他模型优越。首先，要求许多客户接受和相信演化方法并不容易。其次，需要具有相当丰富的风险评估经验和专门知识，才能使用这个模型。对于风险较大的项目来说，在这类项目开发中，如果未能够即时发现风险，势必会造成重大损失。采用螺旋模型显然是很合适的。 \n\n幻灯片 16:\n各种模型的比较\n每个软件开发组织应该选择适合于该组织的软件开发模型，并且应该随着当前正在开发的特定产品特性而变化，以减小所选模型的缺点，充分利用其优点。', 'asdasfsaf');
INSERT INTO `filetable` VALUES ('C_bccec6da', 'pptx', '幻灯片 1:\n软件体系结构\n第2章 软件的生命周期\n\n赵庆玲\n南京理工大学计算机科学与工程学院\nada_zhao@njust.edu.cn\n\n幻灯片 2:\n1、引言\n(1)什么是软件工程\n定义1：软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，这就是软件工程。\n定义2：软件工程是研究和应用如何以系统性的、规范化的、可定量的方法去开发、操纵和维护软件、即把工程应用到软件上。\n(2)什么是软件生命期\n定义3：软件生命期是指软件产品从考虑其概念开始，到该软件产品不再能使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段以及交付使用阶段、运行阶段和维护阶段。有时还有退役阶段。这些阶段可以有重复，执行时也可以有迭代。     \n\n幻灯片 3:\n(3)什么是软件开发生命期\n定义4：软件开发生命期是指软件产品从考虑其概念开始到该软件产品交付使用使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段，以及交付阶段。这些阶段可以有重叠，执行时也可以有迭代。\n(4)什么是软件开发过程  \n定义5：把用户的要求转变成软件产品的过程叫做软件开发过程。此过程包括对用户的要求进行分析，解释成软件需求，把需求变换成设计，把设计用代码来实现，测试该代码，有时还要进行代码安装和把软件交付运行使用。注意：这些活动可以重叠，执行时也可以有迭代。\n定义6：进行一组有组织的活动以把用户的要求转化成软件产品。 \n\n幻灯片 4:\n2、软件开发模型的发展\n在整个软件开发的发展过程中，为了要从宏观上管理软件的开发和维护，就必须对软件的发展过程有总体的认识和描述，即要对软件过程建模。几十年来，软件开发生命周期模型的的发展有了很大变化，提出了一系列的模型以适应软件开发发展的需要。在这里我们提出以下一些主要的软件开发模型：\n1．编码—修正模型(code and fix model)  \n\n幻灯片 5:\n2、软件开发模型的发展\n弊端：\n首先，代码缺少统一规划，低估了设计的重要性，使得代码结构随着修改次数的增加变得越来越坏。以至错误越来越难改，甚至无法改。\n第二，即使有的软件设计得很好，但往往其结果并非用户所需要的。造成软件开发的风险非常大。这主要是因为没有重视需求而造成的。\n第三，由于对测试、维护修改方面考虑不周，使得代码的维护修改非常困难。\n所以，当开发的软件规模不断扩大时，这种开发模型就会引起严重的后果，必须加以改进。 \n\n幻灯片 6:\n2、软件开发模型的发展\n2．瀑布模型(waterfall model)\n由于吸取软件开发早期的教训，人们开始将软件开发视为工程来管理。类似其他工程的管理，软件开发也具有一定的工序。于是，“软件生命周期”这一概念真正被提了出来，并将软件生命周期划分成了：制定计划、需求分析和定义、软件设计、程序编写、软件测试、运行和维护这六个步骤。\n在这一基础上，Winston W. Royce在1970年提出了著名的“瀑布模型”。瀑布模型规定了包括上述六个工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，并试图解决编码—修正模型所带来的问题。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下，呈线性因式。实际情况中，每项开发活动大部分具有以下特点： \n\n幻灯片 7:\n2、软件开发模型的发展\n(1)从上一项开发活动接受该项活动的工作对象，作为输入。\n(2)利用这一输入，实施该项活动应完成的工作内容。\n(3)给出该项活动的工作成果，作为输出传给下一项开发活动。\n(4)对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动，如下图中的向下箭头所表示；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。 \n\n幻灯片 8:\n2、软件开发模型的发展\n\n幻灯片 9:\n2、软件开发模型的发展\n但是瀑布模型同样存在一些问题：\n首先，阶段和阶段划分完全固定，阶段间产生大量的文档，极大地增加了工作量。\n第二，由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。\n第三，前面未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会造成更不理想的后果。\n为此，常常在需求阶段或设计阶段平行地进行几次快速原型，来消除风险和不确定性。该模型长期以来已成为美国政府或军方的软件项目的主要标准。但是瀑布模型的一些根本性缺陷推动着人们继续探索新的模型。相当一部分人认为应考虑采用形式化方法的转换模型以减少人为的错误。 \n\n幻灯片 10:\n2、软件开发模型的发展\n3．转换模型\n其主要思想是用形式化的方法自动生成程序。主要步骤为：\n(1)采用形式化的规格说明书。(2)通过自动系统自动地变换成代码。(3)必要时做一些优化，改进性能。(4)交付用户使用。(5)根据使用的经验来调整形式化的规格说明书。返回(1)重复整个过程。\n转换模型的优点是解决了代码结构经多次修改而变坏的问题；减少了许多中间步骤，如设计、编码、测试等等。但是，转换模型仍有较大局限，表现在：\n(1)自动转换在实际上仅适用于规模很小产品；或某些非常特定领域的产品。(2)用户容易无计划地修改，是否能保证向正确、优化及改进方向发展呢?\n(3)需要非常庞大的支持体系。特别考虑到当前技术飞速发展的特点，这种进行自动转换的系统中应该包含和维护的知识数量呈爆炸性(商品化的软件，硬件平台知识)。 \n\n幻灯片 11:\n4．平行瀑布模型\n现在考虑对瀑布模型的进一步改进。对瀑布模型的各个阶段之间转换时，不一定要求完全按顺序进行。而是可以适当并行开展各阶段的开发工作。在上一个阶段尚未完全结束前，就可开设后一阶段的开发工作。例如，在需求分析完成60％时，就可开始进行这60％的已完成分析部分的设计工作。同时并行进行余留的40％的需求分析。根据不同情况可有不同的并行度。例如：\n(1)用户想法不稳定，比方说，每天变换想法，要求不太清楚的话，则增加并行度。\n(2)短期显示成果的压力大，则可增加并行度。例如，在某种场合，在某些人的眼光中，按期完成70％的测试后的程序，比做完100％的设计，但无一行代码的印象好得多。\n(3)如果可靠性要求高；要求各方面控制和配合很严格；资源及预算严密；技术错误的后果严重时，则需减少并行度。\n一般，对小系统关系不大，但对于大型系统的开发，则需根据实际情况认真分析考虑，难以用一个固定衡量标准。 \n\n幻灯片 12:\n5．演进式开发模型\n由于在项目开发的初期，人们对软件需求的认识常常不够清晰，因而使得在进行项目开发时，难于做到一次开发成功。出现返工，再一次开发常常在所难免。有人说，目标只在于探索可行性，弄清软件需求；第二次则在第一次开发的基础上获得较为满意的软件产品。通常把第一次得到的试验性产品称为“原型”。如果系统十分复杂，就可能要开发多次，每次只开发系统的一部分功能。每次在前一次的基础上，进行改进并扩大性能、功能，直到达到要求。显然，这种依靠演进方式进行开发的演化模型在克服瀑布模型的缺点，减少由于软件需求不明确而给工作带来风险方面，确有显著的效果。这种开发模型的问题是不要把演进式开发模型实际执行成原始的编码—修正模型。 \n\n幻灯片 13:\n6．螺旋模型\n70年代和80年代，硬件技术不断提高，软件系统也不断庞大。而当我们面对一个复杂的大型软件系统时，用“瀑布模型”还是“演化模型”都难于有效地完成项目。于是，\nBarry Boehm在1988年正式发表了软件系统开发的“螺旋模型”。螺旋模型将瀑布模型和演化模型等结合起来，并且强调了其他模型均忽略了的风险分析。这种模型特别适用于庞大而复杂的系统、高风险的系统。对于这些系统，风险是软件开发不可忽视的、潜在的不利因素。它可能在不同程度上损害软件开发过程或软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。\n螺旋模型如图所示。 \n\n幻灯片 15:\n螺旋模型更适合于大型软件的开发，应该说它对于具有高度风险的大型复杂软件系统的开发是最为实际的方法。螺旋模型实际上是吸收和综合了过去各种软件开发模型。每种模型都可用特定情况的螺旋模型来表示。但它强调风险分析，吸收了软件工程“演化”的概念，使得开发人员和客户对每个演化层出现的风险有所了解，继而做出应有的反应。但是，还不能说螺旋模型绝对比其他模型优越。首先，要求许多客户接受和相信演化方法并不容易。其次，需要具有相当丰富的风险评估经验和专门知识，才能使用这个模型。对于风险较大的项目来说，在这类项目开发中，如果未能够即时发现风险，势必会造成重大损失。采用螺旋模型显然是很合适的。 \n\n幻灯片 16:\n各种模型的比较\n每个软件开发组织应该选择适合于该组织的软件开发模型，并且应该随着当前正在开发的特定产品特性而变化，以减小所选模型的缺点，充分利用其优点。', '3123213');
INSERT INTO `filetable` VALUES ('C_bf029078', 'pdf', '链表是动态线性结构，由节点（数据域+指针）串成，无需预分配空间，按需申请释放，空\n间利用率高。常见形态：单链表、带头单链表、双向链表、循环链表。插入删除O(1)，仅改\n指针；随机访问O(n)，须顺序遍历。可轻松实现栈、队列、哈希桶、邻接表、LRU缓存。注\n意哨兵节点简化边界、及时释放内存防泄漏、避免空指针与环。高级变种：跳表（多层索引\n加速搜索）、无锁链表（CAS实现并发）。对比数组：链表增删快、缓存命中率低；数组支持\n随机访问、可能浪费或扩容复制。', '321fwe21312');
INSERT INTO `filetable` VALUES ('C_c1c5ee1d', 'docx', '在计算机组成原理中，指令流水线是提高处理器吞吐率的核心技术。其基本思想是将一条指令的执行过程划分为若干个子阶段，每个阶段由专用硬件并行处理，使得多条指令重叠执行。以经典的五级流水线为例，包含取指（IF）、译码（ID）、执行（EX）、访存（MEM）和写回（WB）五个阶段。当第一条指令进入译码阶段时，第二条指令可同时进入取指阶段，理想情况下每个时钟周期都能完成一条指令，吞吐率提升近5倍。然而，流水线面临三类主要冲突：结构冲突（资源争用，如两条指令同时访问同一存储器）、数据冲突（后续指令依赖前序指令结果，例如RAW真数据相关需通过转发或停顿解决）和控制冲突（分支指令改变PC值导致流水线刷新，可通过分支预测或延迟槽技术缓解）。现代CPU采用动态流水线调度（如Tomasulo算法）和超标量技术（每个周期发射多条指令）进一步挖掘并行性，但伴随的流水线深度增加（如14级以上的Pentium 4）会导致分支预测失败惩罚加重，这体现了计算性能与复杂度的权衡。', '1n8y0gfl');
INSERT INTO `filetable` VALUES ('C_c3dc1daf', 'pdf', '链表是动态线性结构，由节点（数据域+指针）串成，无需预分配空间，按需申请释放，空\n间利用率高。常见形态：单链表、带头单链表、双向链表、循环链表。插入删除O(1)，仅改\n指针；随机访问O(n)，须顺序遍历。可轻松实现栈、队列、哈希桶、邻接表、LRU缓存。注\n意哨兵节点简化边界、及时释放内存防泄漏、避免空指针与环。高级变种：跳表（多层索引\n加速搜索）、无锁链表（CAS实现并发）。对比数组：链表增删快、缓存命中率低；数组支持\n随机访问、可能浪费或扩容复制。', '321fwe21312');
INSERT INTO `filetable` VALUES ('C_c7eb18f7', 'pptx', '幻灯片 1:\n软件体系结构\n第2章 软件的生命周期\n\n赵庆玲\n南京理工大学计算机科学与工程学院\nada_zhao@njust.edu.cn\n\n幻灯片 2:\n1、引言\n(1)什么是软件工程\n定义1：软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，这就是软件工程。\n定义2：软件工程是研究和应用如何以系统性的、规范化的、可定量的方法去开发、操纵和维护软件、即把工程应用到软件上。\n(2)什么是软件生命期\n定义3：软件生命期是指软件产品从考虑其概念开始，到该软件产品不再能使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段以及交付使用阶段、运行阶段和维护阶段。有时还有退役阶段。这些阶段可以有重复，执行时也可以有迭代。     \n\n幻灯片 3:\n(3)什么是软件开发生命期\n定义4：软件开发生命期是指软件产品从考虑其概念开始到该软件产品交付使用使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段，以及交付阶段。这些阶段可以有重叠，执行时也可以有迭代。\n(4)什么是软件开发过程  \n定义5：把用户的要求转变成软件产品的过程叫做软件开发过程。此过程包括对用户的要求进行分析，解释成软件需求，把需求变换成设计，把设计用代码来实现，测试该代码，有时还要进行代码安装和把软件交付运行使用。注意：这些活动可以重叠，执行时也可以有迭代。\n定义6：进行一组有组织的活动以把用户的要求转化成软件产品。 \n\n幻灯片 4:\n2、软件开发模型的发展\n在整个软件开发的发展过程中，为了要从宏观上管理软件的开发和维护，就必须对软件的发展过程有总体的认识和描述，即要对软件过程建模。几十年来，软件开发生命周期模型的的发展有了很大变化，提出了一系列的模型以适应软件开发发展的需要。在这里我们提出以下一些主要的软件开发模型：\n1．编码—修正模型(code and fix model)  \n\n幻灯片 5:\n2、软件开发模型的发展\n弊端：\n首先，代码缺少统一规划，低估了设计的重要性，使得代码结构随着修改次数的增加变得越来越坏。以至错误越来越难改，甚至无法改。\n第二，即使有的软件设计得很好，但往往其结果并非用户所需要的。造成软件开发的风险非常大。这主要是因为没有重视需求而造成的。\n第三，由于对测试、维护修改方面考虑不周，使得代码的维护修改非常困难。\n所以，当开发的软件规模不断扩大时，这种开发模型就会引起严重的后果，必须加以改进。 \n\n幻灯片 6:\n2、软件开发模型的发展\n2．瀑布模型(waterfall model)\n由于吸取软件开发早期的教训，人们开始将软件开发视为工程来管理。类似其他工程的管理，软件开发也具有一定的工序。于是，“软件生命周期”这一概念真正被提了出来，并将软件生命周期划分成了：制定计划、需求分析和定义、软件设计、程序编写、软件测试、运行和维护这六个步骤。\n在这一基础上，Winston W. Royce在1970年提出了著名的“瀑布模型”。瀑布模型规定了包括上述六个工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，并试图解决编码—修正模型所带来的问题。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下，呈线性因式。实际情况中，每项开发活动大部分具有以下特点： \n\n幻灯片 7:\n2、软件开发模型的发展\n(1)从上一项开发活动接受该项活动的工作对象，作为输入。\n(2)利用这一输入，实施该项活动应完成的工作内容。\n(3)给出该项活动的工作成果，作为输出传给下一项开发活动。\n(4)对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动，如下图中的向下箭头所表示；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。 \n\n幻灯片 8:\n2、软件开发模型的发展\n\n幻灯片 9:\n2、软件开发模型的发展\n但是瀑布模型同样存在一些问题：\n首先，阶段和阶段划分完全固定，阶段间产生大量的文档，极大地增加了工作量。\n第二，由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。\n第三，前面未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会造成更不理想的后果。\n为此，常常在需求阶段或设计阶段平行地进行几次快速原型，来消除风险和不确定性。该模型长期以来已成为美国政府或军方的软件项目的主要标准。但是瀑布模型的一些根本性缺陷推动着人们继续探索新的模型。相当一部分人认为应考虑采用形式化方法的转换模型以减少人为的错误。 \n\n幻灯片 10:\n2、软件开发模型的发展\n3．转换模型\n其主要思想是用形式化的方法自动生成程序。主要步骤为：\n(1)采用形式化的规格说明书。(2)通过自动系统自动地变换成代码。(3)必要时做一些优化，改进性能。(4)交付用户使用。(5)根据使用的经验来调整形式化的规格说明书。返回(1)重复整个过程。\n转换模型的优点是解决了代码结构经多次修改而变坏的问题；减少了许多中间步骤，如设计、编码、测试等等。但是，转换模型仍有较大局限，表现在：\n(1)自动转换在实际上仅适用于规模很小产品；或某些非常特定领域的产品。(2)用户容易无计划地修改，是否能保证向正确、优化及改进方向发展呢?\n(3)需要非常庞大的支持体系。特别考虑到当前技术飞速发展的特点，这种进行自动转换的系统中应该包含和维护的知识数量呈爆炸性(商品化的软件，硬件平台知识)。 \n\n幻灯片 11:\n4．平行瀑布模型\n现在考虑对瀑布模型的进一步改进。对瀑布模型的各个阶段之间转换时，不一定要求完全按顺序进行。而是可以适当并行开展各阶段的开发工作。在上一个阶段尚未完全结束前，就可开设后一阶段的开发工作。例如，在需求分析完成60％时，就可开始进行这60％的已完成分析部分的设计工作。同时并行进行余留的40％的需求分析。根据不同情况可有不同的并行度。例如：\n(1)用户想法不稳定，比方说，每天变换想法，要求不太清楚的话，则增加并行度。\n(2)短期显示成果的压力大，则可增加并行度。例如，在某种场合，在某些人的眼光中，按期完成70％的测试后的程序，比做完100％的设计，但无一行代码的印象好得多。\n(3)如果可靠性要求高；要求各方面控制和配合很严格；资源及预算严密；技术错误的后果严重时，则需减少并行度。\n一般，对小系统关系不大，但对于大型系统的开发，则需根据实际情况认真分析考虑，难以用一个固定衡量标准。 \n\n幻灯片 12:\n5．演进式开发模型\n由于在项目开发的初期，人们对软件需求的认识常常不够清晰，因而使得在进行项目开发时，难于做到一次开发成功。出现返工，再一次开发常常在所难免。有人说，目标只在于探索可行性，弄清软件需求；第二次则在第一次开发的基础上获得较为满意的软件产品。通常把第一次得到的试验性产品称为“原型”。如果系统十分复杂，就可能要开发多次，每次只开发系统的一部分功能。每次在前一次的基础上，进行改进并扩大性能、功能，直到达到要求。显然，这种依靠演进方式进行开发的演化模型在克服瀑布模型的缺点，减少由于软件需求不明确而给工作带来风险方面，确有显著的效果。这种开发模型的问题是不要把演进式开发模型实际执行成原始的编码—修正模型。 \n\n幻灯片 13:\n6．螺旋模型\n70年代和80年代，硬件技术不断提高，软件系统也不断庞大。而当我们面对一个复杂的大型软件系统时，用“瀑布模型”还是“演化模型”都难于有效地完成项目。于是，\nBarry Boehm在1988年正式发表了软件系统开发的“螺旋模型”。螺旋模型将瀑布模型和演化模型等结合起来，并且强调了其他模型均忽略了的风险分析。这种模型特别适用于庞大而复杂的系统、高风险的系统。对于这些系统，风险是软件开发不可忽视的、潜在的不利因素。它可能在不同程度上损害软件开发过程或软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。\n螺旋模型如图所示。 \n\n幻灯片 15:\n螺旋模型更适合于大型软件的开发，应该说它对于具有高度风险的大型复杂软件系统的开发是最为实际的方法。螺旋模型实际上是吸收和综合了过去各种软件开发模型。每种模型都可用特定情况的螺旋模型来表示。但它强调风险分析，吸收了软件工程“演化”的概念，使得开发人员和客户对每个演化层出现的风险有所了解，继而做出应有的反应。但是，还不能说螺旋模型绝对比其他模型优越。首先，要求许多客户接受和相信演化方法并不容易。其次，需要具有相当丰富的风险评估经验和专门知识，才能使用这个模型。对于风险较大的项目来说，在这类项目开发中，如果未能够即时发现风险，势必会造成重大损失。采用螺旋模型显然是很合适的。 \n\n幻灯片 16:\n各种模型的比较\n每个软件开发组织应该选择适合于该组织的软件开发模型，并且应该随着当前正在开发的特定产品特性而变化，以减小所选模型的缺点，充分利用其优点。', '3123213');
INSERT INTO `filetable` VALUES ('C_da3ff4b3', 'pptx', '幻灯片 1:\n软件体系结构\n第2章 软件的生命周期\n\n赵庆玲\n南京理工大学计算机科学与工程学院\nada_zhao@njust.edu.cn\n\n幻灯片 2:\n1、引言\n(1)什么是软件工程\n定义1：软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，这就是软件工程。\n定义2：软件工程是研究和应用如何以系统性的、规范化的、可定量的方法去开发、操纵和维护软件、即把工程应用到软件上。\n(2)什么是软件生命期\n定义3：软件生命期是指软件产品从考虑其概念开始，到该软件产品不再能使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段以及交付使用阶段、运行阶段和维护阶段。有时还有退役阶段。这些阶段可以有重复，执行时也可以有迭代。     \n\n幻灯片 3:\n(3)什么是软件开发生命期\n定义4：软件开发生命期是指软件产品从考虑其概念开始到该软件产品交付使用使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段，以及交付阶段。这些阶段可以有重叠，执行时也可以有迭代。\n(4)什么是软件开发过程  \n定义5：把用户的要求转变成软件产品的过程叫做软件开发过程。此过程包括对用户的要求进行分析，解释成软件需求，把需求变换成设计，把设计用代码来实现，测试该代码，有时还要进行代码安装和把软件交付运行使用。注意：这些活动可以重叠，执行时也可以有迭代。\n定义6：进行一组有组织的活动以把用户的要求转化成软件产品。 \n\n幻灯片 4:\n2、软件开发模型的发展\n在整个软件开发的发展过程中，为了要从宏观上管理软件的开发和维护，就必须对软件的发展过程有总体的认识和描述，即要对软件过程建模。几十年来，软件开发生命周期模型的的发展有了很大变化，提出了一系列的模型以适应软件开发发展的需要。在这里我们提出以下一些主要的软件开发模型：\n1．编码—修正模型(code and fix model)  \n\n幻灯片 5:\n2、软件开发模型的发展\n弊端：\n首先，代码缺少统一规划，低估了设计的重要性，使得代码结构随着修改次数的增加变得越来越坏。以至错误越来越难改，甚至无法改。\n第二，即使有的软件设计得很好，但往往其结果并非用户所需要的。造成软件开发的风险非常大。这主要是因为没有重视需求而造成的。\n第三，由于对测试、维护修改方面考虑不周，使得代码的维护修改非常困难。\n所以，当开发的软件规模不断扩大时，这种开发模型就会引起严重的后果，必须加以改进。 \n\n幻灯片 6:\n2、软件开发模型的发展\n2．瀑布模型(waterfall model)\n由于吸取软件开发早期的教训，人们开始将软件开发视为工程来管理。类似其他工程的管理，软件开发也具有一定的工序。于是，“软件生命周期”这一概念真正被提了出来，并将软件生命周期划分成了：制定计划、需求分析和定义、软件设计、程序编写、软件测试、运行和维护这六个步骤。\n在这一基础上，Winston W. Royce在1970年提出了著名的“瀑布模型”。瀑布模型规定了包括上述六个工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，并试图解决编码—修正模型所带来的问题。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下，呈线性因式。实际情况中，每项开发活动大部分具有以下特点： \n\n幻灯片 7:\n2、软件开发模型的发展\n(1)从上一项开发活动接受该项活动的工作对象，作为输入。\n(2)利用这一输入，实施该项活动应完成的工作内容。\n(3)给出该项活动的工作成果，作为输出传给下一项开发活动。\n(4)对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动，如下图中的向下箭头所表示；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。 \n\n幻灯片 8:\n2、软件开发模型的发展\n\n幻灯片 9:\n2、软件开发模型的发展\n但是瀑布模型同样存在一些问题：\n首先，阶段和阶段划分完全固定，阶段间产生大量的文档，极大地增加了工作量。\n第二，由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。\n第三，前面未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会造成更不理想的后果。\n为此，常常在需求阶段或设计阶段平行地进行几次快速原型，来消除风险和不确定性。该模型长期以来已成为美国政府或军方的软件项目的主要标准。但是瀑布模型的一些根本性缺陷推动着人们继续探索新的模型。相当一部分人认为应考虑采用形式化方法的转换模型以减少人为的错误。 \n\n幻灯片 10:\n2、软件开发模型的发展\n3．转换模型\n其主要思想是用形式化的方法自动生成程序。主要步骤为：\n(1)采用形式化的规格说明书。(2)通过自动系统自动地变换成代码。(3)必要时做一些优化，改进性能。(4)交付用户使用。(5)根据使用的经验来调整形式化的规格说明书。返回(1)重复整个过程。\n转换模型的优点是解决了代码结构经多次修改而变坏的问题；减少了许多中间步骤，如设计、编码、测试等等。但是，转换模型仍有较大局限，表现在：\n(1)自动转换在实际上仅适用于规模很小产品；或某些非常特定领域的产品。(2)用户容易无计划地修改，是否能保证向正确、优化及改进方向发展呢?\n(3)需要非常庞大的支持体系。特别考虑到当前技术飞速发展的特点，这种进行自动转换的系统中应该包含和维护的知识数量呈爆炸性(商品化的软件，硬件平台知识)。 \n\n幻灯片 11:\n4．平行瀑布模型\n现在考虑对瀑布模型的进一步改进。对瀑布模型的各个阶段之间转换时，不一定要求完全按顺序进行。而是可以适当并行开展各阶段的开发工作。在上一个阶段尚未完全结束前，就可开设后一阶段的开发工作。例如，在需求分析完成60％时，就可开始进行这60％的已完成分析部分的设计工作。同时并行进行余留的40％的需求分析。根据不同情况可有不同的并行度。例如：\n(1)用户想法不稳定，比方说，每天变换想法，要求不太清楚的话，则增加并行度。\n(2)短期显示成果的压力大，则可增加并行度。例如，在某种场合，在某些人的眼光中，按期完成70％的测试后的程序，比做完100％的设计，但无一行代码的印象好得多。\n(3)如果可靠性要求高；要求各方面控制和配合很严格；资源及预算严密；技术错误的后果严重时，则需减少并行度。\n一般，对小系统关系不大，但对于大型系统的开发，则需根据实际情况认真分析考虑，难以用一个固定衡量标准。 \n\n幻灯片 12:\n5．演进式开发模型\n由于在项目开发的初期，人们对软件需求的认识常常不够清晰，因而使得在进行项目开发时，难于做到一次开发成功。出现返工，再一次开发常常在所难免。有人说，目标只在于探索可行性，弄清软件需求；第二次则在第一次开发的基础上获得较为满意的软件产品。通常把第一次得到的试验性产品称为“原型”。如果系统十分复杂，就可能要开发多次，每次只开发系统的一部分功能。每次在前一次的基础上，进行改进并扩大性能、功能，直到达到要求。显然，这种依靠演进方式进行开发的演化模型在克服瀑布模型的缺点，减少由于软件需求不明确而给工作带来风险方面，确有显著的效果。这种开发模型的问题是不要把演进式开发模型实际执行成原始的编码—修正模型。 \n\n幻灯片 13:\n6．螺旋模型\n70年代和80年代，硬件技术不断提高，软件系统也不断庞大。而当我们面对一个复杂的大型软件系统时，用“瀑布模型”还是“演化模型”都难于有效地完成项目。于是，\nBarry Boehm在1988年正式发表了软件系统开发的“螺旋模型”。螺旋模型将瀑布模型和演化模型等结合起来，并且强调了其他模型均忽略了的风险分析。这种模型特别适用于庞大而复杂的系统、高风险的系统。对于这些系统，风险是软件开发不可忽视的、潜在的不利因素。它可能在不同程度上损害软件开发过程或软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。\n螺旋模型如图所示。 \n\n幻灯片 15:\n螺旋模型更适合于大型软件的开发，应该说它对于具有高度风险的大型复杂软件系统的开发是最为实际的方法。螺旋模型实际上是吸收和综合了过去各种软件开发模型。每种模型都可用特定情况的螺旋模型来表示。但它强调风险分析，吸收了软件工程“演化”的概念，使得开发人员和客户对每个演化层出现的风险有所了解，继而做出应有的反应。但是，还不能说螺旋模型绝对比其他模型优越。首先，要求许多客户接受和相信演化方法并不容易。其次，需要具有相当丰富的风险评估经验和专门知识，才能使用这个模型。对于风险较大的项目来说，在这类项目开发中，如果未能够即时发现风险，势必会造成重大损失。采用螺旋模型显然是很合适的。 \n\n幻灯片 16:\n各种模型的比较\n每个软件开发组织应该选择适合于该组织的软件开发模型，并且应该随着当前正在开发的特定产品特性而变化，以减小所选模型的缺点，充分利用其优点。', 'ded');
INSERT INTO `filetable` VALUES ('C_db5d9df1', 'pptx', '幻灯片 1:\n软件体系结构\n第2章 软件的生命周期\n\n赵庆玲\n南京理工大学计算机科学与工程学院\nada_zhao@njust.edu.cn\n\n幻灯片 2:\n1、引言\n(1)什么是软件工程\n定义1：软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，这就是软件工程。\n定义2：软件工程是研究和应用如何以系统性的、规范化的、可定量的方法去开发、操纵和维护软件、即把工程应用到软件上。\n(2)什么是软件生命期\n定义3：软件生命期是指软件产品从考虑其概念开始，到该软件产品不再能使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段以及交付使用阶段、运行阶段和维护阶段。有时还有退役阶段。这些阶段可以有重复，执行时也可以有迭代。     \n\n幻灯片 3:\n(3)什么是软件开发生命期\n定义4：软件开发生命期是指软件产品从考虑其概念开始到该软件产品交付使用使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段，以及交付阶段。这些阶段可以有重叠，执行时也可以有迭代。\n(4)什么是软件开发过程  \n定义5：把用户的要求转变成软件产品的过程叫做软件开发过程。此过程包括对用户的要求进行分析，解释成软件需求，把需求变换成设计，把设计用代码来实现，测试该代码，有时还要进行代码安装和把软件交付运行使用。注意：这些活动可以重叠，执行时也可以有迭代。\n定义6：进行一组有组织的活动以把用户的要求转化成软件产品。 \n\n幻灯片 4:\n2、软件开发模型的发展\n在整个软件开发的发展过程中，为了要从宏观上管理软件的开发和维护，就必须对软件的发展过程有总体的认识和描述，即要对软件过程建模。几十年来，软件开发生命周期模型的的发展有了很大变化，提出了一系列的模型以适应软件开发发展的需要。在这里我们提出以下一些主要的软件开发模型：\n1．编码—修正模型(code and fix model)  \n\n幻灯片 5:\n2、软件开发模型的发展\n弊端：\n首先，代码缺少统一规划，低估了设计的重要性，使得代码结构随着修改次数的增加变得越来越坏。以至错误越来越难改，甚至无法改。\n第二，即使有的软件设计得很好，但往往其结果并非用户所需要的。造成软件开发的风险非常大。这主要是因为没有重视需求而造成的。\n第三，由于对测试、维护修改方面考虑不周，使得代码的维护修改非常困难。\n所以，当开发的软件规模不断扩大时，这种开发模型就会引起严重的后果，必须加以改进。 \n\n幻灯片 6:\n2、软件开发模型的发展\n2．瀑布模型(waterfall model)\n由于吸取软件开发早期的教训，人们开始将软件开发视为工程来管理。类似其他工程的管理，软件开发也具有一定的工序。于是，“软件生命周期”这一概念真正被提了出来，并将软件生命周期划分成了：制定计划、需求分析和定义、软件设计、程序编写、软件测试、运行和维护这六个步骤。\n在这一基础上，Winston W. Royce在1970年提出了著名的“瀑布模型”。瀑布模型规定了包括上述六个工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，并试图解决编码—修正模型所带来的问题。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下，呈线性因式。实际情况中，每项开发活动大部分具有以下特点： \n\n幻灯片 7:\n2、软件开发模型的发展\n(1)从上一项开发活动接受该项活动的工作对象，作为输入。\n(2)利用这一输入，实施该项活动应完成的工作内容。\n(3)给出该项活动的工作成果，作为输出传给下一项开发活动。\n(4)对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动，如下图中的向下箭头所表示；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。 \n\n幻灯片 8:\n2、软件开发模型的发展\n\n幻灯片 9:\n2、软件开发模型的发展\n但是瀑布模型同样存在一些问题：\n首先，阶段和阶段划分完全固定，阶段间产生大量的文档，极大地增加了工作量。\n第二，由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。\n第三，前面未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会造成更不理想的后果。\n为此，常常在需求阶段或设计阶段平行地进行几次快速原型，来消除风险和不确定性。该模型长期以来已成为美国政府或军方的软件项目的主要标准。但是瀑布模型的一些根本性缺陷推动着人们继续探索新的模型。相当一部分人认为应考虑采用形式化方法的转换模型以减少人为的错误。 \n\n幻灯片 10:\n2、软件开发模型的发展\n3．转换模型\n其主要思想是用形式化的方法自动生成程序。主要步骤为：\n(1)采用形式化的规格说明书。(2)通过自动系统自动地变换成代码。(3)必要时做一些优化，改进性能。(4)交付用户使用。(5)根据使用的经验来调整形式化的规格说明书。返回(1)重复整个过程。\n转换模型的优点是解决了代码结构经多次修改而变坏的问题；减少了许多中间步骤，如设计、编码、测试等等。但是，转换模型仍有较大局限，表现在：\n(1)自动转换在实际上仅适用于规模很小产品；或某些非常特定领域的产品。(2)用户容易无计划地修改，是否能保证向正确、优化及改进方向发展呢?\n(3)需要非常庞大的支持体系。特别考虑到当前技术飞速发展的特点，这种进行自动转换的系统中应该包含和维护的知识数量呈爆炸性(商品化的软件，硬件平台知识)。 \n\n幻灯片 11:\n4．平行瀑布模型\n现在考虑对瀑布模型的进一步改进。对瀑布模型的各个阶段之间转换时，不一定要求完全按顺序进行。而是可以适当并行开展各阶段的开发工作。在上一个阶段尚未完全结束前，就可开设后一阶段的开发工作。例如，在需求分析完成60％时，就可开始进行这60％的已完成分析部分的设计工作。同时并行进行余留的40％的需求分析。根据不同情况可有不同的并行度。例如：\n(1)用户想法不稳定，比方说，每天变换想法，要求不太清楚的话，则增加并行度。\n(2)短期显示成果的压力大，则可增加并行度。例如，在某种场合，在某些人的眼光中，按期完成70％的测试后的程序，比做完100％的设计，但无一行代码的印象好得多。\n(3)如果可靠性要求高；要求各方面控制和配合很严格；资源及预算严密；技术错误的后果严重时，则需减少并行度。\n一般，对小系统关系不大，但对于大型系统的开发，则需根据实际情况认真分析考虑，难以用一个固定衡量标准。 \n\n幻灯片 12:\n5．演进式开发模型\n由于在项目开发的初期，人们对软件需求的认识常常不够清晰，因而使得在进行项目开发时，难于做到一次开发成功。出现返工，再一次开发常常在所难免。有人说，目标只在于探索可行性，弄清软件需求；第二次则在第一次开发的基础上获得较为满意的软件产品。通常把第一次得到的试验性产品称为“原型”。如果系统十分复杂，就可能要开发多次，每次只开发系统的一部分功能。每次在前一次的基础上，进行改进并扩大性能、功能，直到达到要求。显然，这种依靠演进方式进行开发的演化模型在克服瀑布模型的缺点，减少由于软件需求不明确而给工作带来风险方面，确有显著的效果。这种开发模型的问题是不要把演进式开发模型实际执行成原始的编码—修正模型。 \n\n幻灯片 13:\n6．螺旋模型\n70年代和80年代，硬件技术不断提高，软件系统也不断庞大。而当我们面对一个复杂的大型软件系统时，用“瀑布模型”还是“演化模型”都难于有效地完成项目。于是，\nBarry Boehm在1988年正式发表了软件系统开发的“螺旋模型”。螺旋模型将瀑布模型和演化模型等结合起来，并且强调了其他模型均忽略了的风险分析。这种模型特别适用于庞大而复杂的系统、高风险的系统。对于这些系统，风险是软件开发不可忽视的、潜在的不利因素。它可能在不同程度上损害软件开发过程或软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。\n螺旋模型如图所示。 \n\n幻灯片 15:\n螺旋模型更适合于大型软件的开发，应该说它对于具有高度风险的大型复杂软件系统的开发是最为实际的方法。螺旋模型实际上是吸收和综合了过去各种软件开发模型。每种模型都可用特定情况的螺旋模型来表示。但它强调风险分析，吸收了软件工程“演化”的概念，使得开发人员和客户对每个演化层出现的风险有所了解，继而做出应有的反应。但是，还不能说螺旋模型绝对比其他模型优越。首先，要求许多客户接受和相信演化方法并不容易。其次，需要具有相当丰富的风险评估经验和专门知识，才能使用这个模型。对于风险较大的项目来说，在这类项目开发中，如果未能够即时发现风险，势必会造成重大损失。采用螺旋模型显然是很合适的。 \n\n幻灯片 16:\n各种模型的比较\n每个软件开发组织应该选择适合于该组织的软件开发模型，并且应该随着当前正在开发的特定产品特性而变化，以减小所选模型的缺点，充分利用其优点。', '3123213');
INSERT INTO `filetable` VALUES ('C_ef0de12a', 'pptx', '幻灯片 1:\n软件体系结构\n第2章 软件的生命周期\n\n赵庆玲\n南京理工大学计算机科学与工程学院\nada_zhao@njust.edu.cn\n\n幻灯片 2:\n1、引言\n(1)什么是软件工程\n定义1：软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，这就是软件工程。\n定义2：软件工程是研究和应用如何以系统性的、规范化的、可定量的方法去开发、操纵和维护软件、即把工程应用到软件上。\n(2)什么是软件生命期\n定义3：软件生命期是指软件产品从考虑其概念开始，到该软件产品不再能使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段以及交付使用阶段、运行阶段和维护阶段。有时还有退役阶段。这些阶段可以有重复，执行时也可以有迭代。     \n\n幻灯片 3:\n(3)什么是软件开发生命期\n定义4：软件开发生命期是指软件产品从考虑其概念开始到该软件产品交付使用使用为止的整个时期。一般包括概念阶段、需求阶段、设计阶段、实现阶段、测试阶段、安装阶段，以及交付阶段。这些阶段可以有重叠，执行时也可以有迭代。\n(4)什么是软件开发过程  \n定义5：把用户的要求转变成软件产品的过程叫做软件开发过程。此过程包括对用户的要求进行分析，解释成软件需求，把需求变换成设计，把设计用代码来实现，测试该代码，有时还要进行代码安装和把软件交付运行使用。注意：这些活动可以重叠，执行时也可以有迭代。\n定义6：进行一组有组织的活动以把用户的要求转化成软件产品。 \n\n幻灯片 4:\n2、软件开发模型的发展\n在整个软件开发的发展过程中，为了要从宏观上管理软件的开发和维护，就必须对软件的发展过程有总体的认识和描述，即要对软件过程建模。几十年来，软件开发生命周期模型的的发展有了很大变化，提出了一系列的模型以适应软件开发发展的需要。在这里我们提出以下一些主要的软件开发模型：\n1．编码—修正模型(code and fix model)  \n\n幻灯片 5:\n2、软件开发模型的发展\n弊端：\n首先，代码缺少统一规划，低估了设计的重要性，使得代码结构随着修改次数的增加变得越来越坏。以至错误越来越难改，甚至无法改。\n第二，即使有的软件设计得很好，但往往其结果并非用户所需要的。造成软件开发的风险非常大。这主要是因为没有重视需求而造成的。\n第三，由于对测试、维护修改方面考虑不周，使得代码的维护修改非常困难。\n所以，当开发的软件规模不断扩大时，这种开发模型就会引起严重的后果，必须加以改进。 \n\n幻灯片 6:\n2、软件开发模型的发展\n2．瀑布模型(waterfall model)\n由于吸取软件开发早期的教训，人们开始将软件开发视为工程来管理。类似其他工程的管理，软件开发也具有一定的工序。于是，“软件生命周期”这一概念真正被提了出来，并将软件生命周期划分成了：制定计划、需求分析和定义、软件设计、程序编写、软件测试、运行和维护这六个步骤。\n在这一基础上，Winston W. Royce在1970年提出了著名的“瀑布模型”。瀑布模型规定了包括上述六个工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，并试图解决编码—修正模型所带来的问题。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下，呈线性因式。实际情况中，每项开发活动大部分具有以下特点： \n\n幻灯片 7:\n2、软件开发模型的发展\n(1)从上一项开发活动接受该项活动的工作对象，作为输入。\n(2)利用这一输入，实施该项活动应完成的工作内容。\n(3)给出该项活动的工作成果，作为输出传给下一项开发活动。\n(4)对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动，如下图中的向下箭头所表示；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。 \n\n幻灯片 8:\n2、软件开发模型的发展\n\n幻灯片 9:\n2、软件开发模型的发展\n但是瀑布模型同样存在一些问题：\n首先，阶段和阶段划分完全固定，阶段间产生大量的文档，极大地增加了工作量。\n第二，由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。\n第三，前面未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会造成更不理想的后果。\n为此，常常在需求阶段或设计阶段平行地进行几次快速原型，来消除风险和不确定性。该模型长期以来已成为美国政府或军方的软件项目的主要标准。但是瀑布模型的一些根本性缺陷推动着人们继续探索新的模型。相当一部分人认为应考虑采用形式化方法的转换模型以减少人为的错误。 \n\n幻灯片 10:\n2、软件开发模型的发展\n3．转换模型\n其主要思想是用形式化的方法自动生成程序。主要步骤为：\n(1)采用形式化的规格说明书。(2)通过自动系统自动地变换成代码。(3)必要时做一些优化，改进性能。(4)交付用户使用。(5)根据使用的经验来调整形式化的规格说明书。返回(1)重复整个过程。\n转换模型的优点是解决了代码结构经多次修改而变坏的问题；减少了许多中间步骤，如设计、编码、测试等等。但是，转换模型仍有较大局限，表现在：\n(1)自动转换在实际上仅适用于规模很小产品；或某些非常特定领域的产品。(2)用户容易无计划地修改，是否能保证向正确、优化及改进方向发展呢?\n(3)需要非常庞大的支持体系。特别考虑到当前技术飞速发展的特点，这种进行自动转换的系统中应该包含和维护的知识数量呈爆炸性(商品化的软件，硬件平台知识)。 \n\n幻灯片 11:\n4．平行瀑布模型\n现在考虑对瀑布模型的进一步改进。对瀑布模型的各个阶段之间转换时，不一定要求完全按顺序进行。而是可以适当并行开展各阶段的开发工作。在上一个阶段尚未完全结束前，就可开设后一阶段的开发工作。例如，在需求分析完成60％时，就可开始进行这60％的已完成分析部分的设计工作。同时并行进行余留的40％的需求分析。根据不同情况可有不同的并行度。例如：\n(1)用户想法不稳定，比方说，每天变换想法，要求不太清楚的话，则增加并行度。\n(2)短期显示成果的压力大，则可增加并行度。例如，在某种场合，在某些人的眼光中，按期完成70％的测试后的程序，比做完100％的设计，但无一行代码的印象好得多。\n(3)如果可靠性要求高；要求各方面控制和配合很严格；资源及预算严密；技术错误的后果严重时，则需减少并行度。\n一般，对小系统关系不大，但对于大型系统的开发，则需根据实际情况认真分析考虑，难以用一个固定衡量标准。 \n\n幻灯片 12:\n5．演进式开发模型\n由于在项目开发的初期，人们对软件需求的认识常常不够清晰，因而使得在进行项目开发时，难于做到一次开发成功。出现返工，再一次开发常常在所难免。有人说，目标只在于探索可行性，弄清软件需求；第二次则在第一次开发的基础上获得较为满意的软件产品。通常把第一次得到的试验性产品称为“原型”。如果系统十分复杂，就可能要开发多次，每次只开发系统的一部分功能。每次在前一次的基础上，进行改进并扩大性能、功能，直到达到要求。显然，这种依靠演进方式进行开发的演化模型在克服瀑布模型的缺点，减少由于软件需求不明确而给工作带来风险方面，确有显著的效果。这种开发模型的问题是不要把演进式开发模型实际执行成原始的编码—修正模型。 \n\n幻灯片 13:\n6．螺旋模型\n70年代和80年代，硬件技术不断提高，软件系统也不断庞大。而当我们面对一个复杂的大型软件系统时，用“瀑布模型”还是“演化模型”都难于有效地完成项目。于是，\nBarry Boehm在1988年正式发表了软件系统开发的“螺旋模型”。螺旋模型将瀑布模型和演化模型等结合起来，并且强调了其他模型均忽略了的风险分析。这种模型特别适用于庞大而复杂的系统、高风险的系统。对于这些系统，风险是软件开发不可忽视的、潜在的不利因素。它可能在不同程度上损害软件开发过程或软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。\n螺旋模型如图所示。 \n\n幻灯片 15:\n螺旋模型更适合于大型软件的开发，应该说它对于具有高度风险的大型复杂软件系统的开发是最为实际的方法。螺旋模型实际上是吸收和综合了过去各种软件开发模型。每种模型都可用特定情况的螺旋模型来表示。但它强调风险分析，吸收了软件工程“演化”的概念，使得开发人员和客户对每个演化层出现的风险有所了解，继而做出应有的反应。但是，还不能说螺旋模型绝对比其他模型优越。首先，要求许多客户接受和相信演化方法并不容易。其次，需要具有相当丰富的风险评估经验和专门知识，才能使用这个模型。对于风险较大的项目来说，在这类项目开发中，如果未能够即时发现风险，势必会造成重大损失。采用螺旋模型显然是很合适的。 \n\n幻灯片 16:\n各种模型的比较\n每个软件开发组织应该选择适合于该组织的软件开发模型，并且应该随着当前正在开发的特定产品特性而变化，以减小所选模型的缺点，充分利用其优点。', '3123213');

-- ----------------------------
-- Table structure for questiontable
-- ----------------------------
DROP TABLE IF EXISTS `questiontable`;
CREATE TABLE `questiontable`  (
  `questionId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `speechId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `optionA` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `optionB` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `optionC` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `optionD` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `answer` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `isUsed` int NOT NULL,
  PRIMARY KEY (`questionId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of questiontable
-- ----------------------------
INSERT INTO `questiontable` VALUES ('Q_38cac3f1', 'gat222l9', '问题：以下哪种冲突是由于多条指令需要同时使用同一硬件资源引起的？', '数据冲突', '控制冲突', '结构冲突', '时序冲突', 'C', 1);
INSERT INTO `questiontable` VALUES ('Q_b40586ce', 'gat222l9', '问题：现代CPU采用超标量技术的主要目的是：', '减少分支预测失败惩罚', '每个时钟周期发射多条指令', '降低流水线深度', '解决结构冲突', 'B', 1);
INSERT INTO `questiontable` VALUES ('Q_d464e5c4', 'gat222l9', '问题：关于流水线深度增加的影响，以下说法正确的是：', '总是能提高处理器性能', '会减少分支预测失败的惩罚', '可能导致性能下降', '完全消除数据冲突', 'C', 1);
INSERT INTO `questiontable` VALUES ('Q_de9df114', 'gat222l9', '1. 问题：在经典的五级流水线中，当第一条指令处于执行阶段时，第二条指令处于哪个阶段？', '取指', '译码', '访存', '写回', 'B', 1);
INSERT INTO `questiontable` VALUES ('Q_fc82a38a', 'gat222l9', '问题：对于RAW（读后写）数据相关，最有效的解决方案是：', '插入空操作指令', '使用分支预测', '采用数据转发技术', '增加流水线级数', 'C', 1);

-- ----------------------------
-- Table structure for speechtable
-- ----------------------------
DROP TABLE IF EXISTS `speechtable`;
CREATE TABLE `speechtable`  (
  `speechId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `organizer` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `speaker` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `startTime` datetime NOT NULL,
  `endTime` datetime NOT NULL,
  `status` int NOT NULL,
  PRIMARY KEY (`speechId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of speechtable
-- ----------------------------
INSERT INTO `speechtable` VALUES ('1n8y0gfl', 'web技术', 'web第一讲', '3wfa738y', '53wmudqy', '2025-07-25 22:45:13', '2025-07-25 22:52:40', 2);
INSERT INTO `speechtable` VALUES ('321fwe21312', 'J2EE', 'J2EE', '3333', '2222', '2025-07-17 20:59:52', '2025-07-17 20:59:55', 1);
INSERT INTO `speechtable` VALUES ('3bcwe3213bdui1', 'web开发课程演讲', 'web开发结束...', '3333', '2222', '2025-07-15 13:45:25', '2025-07-15 22:00:03', 2);
INSERT INTO `speechtable` VALUES ('55fwwk26', '英语', '杀杀杀', '3wfa738y', '53wmudqy', '2025-07-25 22:11:59', '2025-07-25 22:12:07', 2);
INSERT INTO `speechtable` VALUES ('gat222l9', '小学数学', '加法运算', '3wfa738y', '53wmudqy', '2025-07-25 23:18:15', '2025-07-25 23:27:15', 2);
INSERT INTO `speechtable` VALUES ('is2i80to', '线性代数', '线性代数第一讲', '3wfa738y', '53wmudqy', '2025-07-25 22:37:01', '2025-07-25 22:40:59', 2);
INSERT INTO `speechtable` VALUES ('jcmj783v', '化学', '111', '3wfa738y', '53wmudqy', '2025-07-25 22:20:08', '2025-07-25 22:37:57', 2);
INSERT INTO `speechtable` VALUES ('m25cd7ru', '物理', '111', '3wfa738y', '53wmudqy', '2025-07-25 22:15:38', '2025-07-25 22:17:55', 2);
INSERT INTO `speechtable` VALUES ('s4b6kld7', '高数', '高等数学第一讲', '3wfa738y', '53wmudqy', '2025-07-25 21:36:38', '2025-07-25 22:03:06', 2);
INSERT INTO `speechtable` VALUES ('z97w2i7q', 'vue', 'vue第一讲', '3wfa738y', '53wmudqy', '2025-07-25 23:00:12', '2025-07-25 23:16:41', 2);

-- ----------------------------
-- Table structure for spittable
-- ----------------------------
DROP TABLE IF EXISTS `spittable`;
CREATE TABLE `spittable`  (
  `spitId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `speechId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `time` datetime NOT NULL,
  PRIMARY KEY (`spitId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of spittable
-- ----------------------------
INSERT INTO `spittable` VALUES ('1vufrvmk', 'gat222l9', '太烦躁了', '2025-07-25 23:22:16');
INSERT INTO `spittable` VALUES ('26rq4t8i', '1n8y0gfl', '太乏味了', '2025-07-25 22:49:56');
INSERT INTO `spittable` VALUES ('2on13sqp', 'z97w2i7q', '太乏味了', '2025-07-25 23:05:00');
INSERT INTO `spittable` VALUES ('6nu9k76x', '321fwe21312', '1212', '2025-07-25 03:30:25');
INSERT INTO `spittable` VALUES ('lt6i8rhe', '321fwe21312', '演讲质量差1', '2025-07-21 08:06:38');
INSERT INTO `spittable` VALUES ('qw3785q6', '321fwe21312', '88', '2025-07-25 13:40:29');
INSERT INTO `spittable` VALUES ('rkim7h1e', 's4b6kld7', '这个讲演不行', '2025-07-25 21:59:44');
INSERT INTO `spittable` VALUES ('w23787hg', '321fwe21312', '演讲质量差', '2025-07-21 08:06:38');

-- ----------------------------
-- Table structure for surelation
-- ----------------------------
DROP TABLE IF EXISTS `surelation`;
CREATE TABLE `surelation`  (
  `speechId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `userId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of surelation
-- ----------------------------
INSERT INTO `surelation` VALUES ('321fwe21312', '3333');
INSERT INTO `surelation` VALUES ('321fwe21312', '3333');
INSERT INTO `surelation` VALUES ('321fwe21312', '3333');
INSERT INTO `surelation` VALUES ('321fwe21312', '1111');
INSERT INTO `surelation` VALUES ('s4b6kld7', '53wmudqy');
INSERT INTO `surelation` VALUES ('s4b6kld7', 'e03d2197');
INSERT INTO `surelation` VALUES ('s4b6kld7', '3wfa738y');
INSERT INTO `surelation` VALUES ('55fwwk26', '53wmudqy');
INSERT INTO `surelation` VALUES ('m25cd7ru', 'e03d2197');
INSERT INTO `surelation` VALUES ('is2i80to', '53wmudqy');
INSERT INTO `surelation` VALUES ('1n8y0gfl', '53wmudqy');
INSERT INTO `surelation` VALUES ('z97w2i7q', '53wmudqy');
INSERT INTO `surelation` VALUES ('gat222l9', '53wmudqy');

-- ----------------------------
-- Table structure for tqrelation
-- ----------------------------
DROP TABLE IF EXISTS `tqrelation`;
CREATE TABLE `tqrelation`  (
  `testId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `questionId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tqrelation
-- ----------------------------
INSERT INTO `tqrelation` VALUES ('a045pspx', '2312321d');
INSERT INTO `tqrelation` VALUES ('a045pspx', '321d234s1');
INSERT INTO `tqrelation` VALUES ('2dgrh14n', 'Q_12f1b5f0');
INSERT INTO `tqrelation` VALUES ('2dgrh14n', 'Q_266ccd74');
INSERT INTO `tqrelation` VALUES ('f14ss642', 'Q_12f1b5f0');
INSERT INTO `tqrelation` VALUES ('f14ss642', 'Q_266ccd74');
INSERT INTO `tqrelation` VALUES ('f14ss642', 'Q_2ca6ce53');
INSERT INTO `tqrelation` VALUES ('b37a7n9a', 'Q_fe2493ea');
INSERT INTO `tqrelation` VALUES ('b37a7n9a', 'Q_eb744363');
INSERT INTO `tqrelation` VALUES ('b37a7n9a', 'Q_e6fa1101');
INSERT INTO `tqrelation` VALUES ('nq6s15t2', 'Q_108f7fc1');
INSERT INTO `tqrelation` VALUES ('nq6s15t2', 'Q_28b91a71');
INSERT INTO `tqrelation` VALUES ('nq6s15t2', 'Q_29f96377');
INSERT INTO `tqrelation` VALUES ('326346fh', 'Q_bcf839a9');
INSERT INTO `tqrelation` VALUES ('326346fh', 'Q_b348577d');
INSERT INTO `tqrelation` VALUES ('326346fh', 'Q_9f2c1d8f');
INSERT INTO `tqrelation` VALUES ('326346fh', 'Q_5068d891');
INSERT INTO `tqrelation` VALUES ('m9t2htcy', 'Q_1d8c3003');
INSERT INTO `tqrelation` VALUES ('m9t2htcy', 'Q_2c1c30d6');
INSERT INTO `tqrelation` VALUES ('m9t2htcy', 'Q_59cd7d87');
INSERT INTO `tqrelation` VALUES ('p7y0j4cw', 'Q_c8f220e5');
INSERT INTO `tqrelation` VALUES ('p7y0j4cw', 'Q_f303631d');
INSERT INTO `tqrelation` VALUES ('3i5n11mb', 'Q_48648cc7');
INSERT INTO `tqrelation` VALUES ('3i5n11mb', 'Q_79b6c537');
INSERT INTO `tqrelation` VALUES ('122r1op0', 'Q_b438c112');
INSERT INTO `tqrelation` VALUES ('122r1op0', 'Q_cf3ae099');
INSERT INTO `tqrelation` VALUES ('c2708p3u', 'Q_2a1865b6');
INSERT INTO `tqrelation` VALUES ('c2708p3u', 'Q_8ade1445');
INSERT INTO `tqrelation` VALUES ('sp72pncu', 'Q_0c8c251c');
INSERT INTO `tqrelation` VALUES ('sp72pncu', 'Q_1c88c683');
INSERT INTO `tqrelation` VALUES ('sp72pncu', 'Q_284b56f5');
INSERT INTO `tqrelation` VALUES ('sp72pncu', 'Q_b0ff726c');
INSERT INTO `tqrelation` VALUES ('sp72pncu', 'Q_b185051a');
INSERT INTO `tqrelation` VALUES ('jk35v25r', 'Q_22d9d7bc');
INSERT INTO `tqrelation` VALUES ('jk35v25r', 'Q_307cc854');
INSERT INTO `tqrelation` VALUES ('jk35v25r', 'Q_5dac4cd5');
INSERT INTO `tqrelation` VALUES ('jk35v25r', 'Q_d5bb614b');
INSERT INTO `tqrelation` VALUES ('jk35v25r', 'Q_e246e161');
INSERT INTO `tqrelation` VALUES ('84182ep8', 'Q_38cac3f1');
INSERT INTO `tqrelation` VALUES ('84182ep8', 'Q_b40586ce');
INSERT INTO `tqrelation` VALUES ('84182ep8', 'Q_d464e5c4');
INSERT INTO `tqrelation` VALUES ('84182ep8', 'Q_de9df114');
INSERT INTO `tqrelation` VALUES ('84182ep8', 'Q_fc82a38a');

-- ----------------------------
-- Table structure for tsrelation
-- ----------------------------
DROP TABLE IF EXISTS `tsrelation`;
CREATE TABLE `tsrelation`  (
  `testId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `speechId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `state` int NOT NULL,
  PRIMARY KEY (`testId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tsrelation
-- ----------------------------
INSERT INTO `tsrelation` VALUES ('122r1op0', '321fwe21312', 0);
INSERT INTO `tsrelation` VALUES ('326346fh', '321fwe21312', 1);
INSERT INTO `tsrelation` VALUES ('3i5n11mb', '321fwe21312', 0);
INSERT INTO `tsrelation` VALUES ('84182ep8', 'gat222l9', 1);
INSERT INTO `tsrelation` VALUES ('c2708p3u', 's4b6kld7', 0);
INSERT INTO `tsrelation` VALUES ('jk35v25r', 'z97w2i7q', 1);
INSERT INTO `tsrelation` VALUES ('m9t2htcy', '321fwe21312', 1);
INSERT INTO `tsrelation` VALUES ('p7y0j4cw', '321fwe21312', 0);
INSERT INTO `tsrelation` VALUES ('sp72pncu', '1n8y0gfl', 1);

-- ----------------------------
-- Table structure for usertable
-- ----------------------------
DROP TABLE IF EXISTS `usertable`;
CREATE TABLE `usertable`  (
  `userId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `userphone` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `role` int NOT NULL,
  PRIMARY KEY (`userId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of usertable
-- ----------------------------
INSERT INTO `usertable` VALUES ('00', '系统账户', '00000000', '系统账户', '00000000', 0);
INSERT INTO `usertable` VALUES ('1111', '437121@qq.com', '123456', '王五', '13123', 1);
INSERT INTO `usertable` VALUES ('2222', '437111@qq.com', '123456', '李四', '13123', 2);
INSERT INTO `usertable` VALUES ('3333', '437110@qq.com', '123456', '张三', '10086', 3);
INSERT INTO `usertable` VALUES ('3wfa738y', '10086@qq.com', '123456', '小辉', '15772305989', 3);
INSERT INTO `usertable` VALUES ('53wmudqy', '10084@qq.com', '123456', '小牛', '17522669898', 2);
INSERT INTO `usertable` VALUES ('e03d2197', '10085@qq.com', '123456', '小玉', '18355962064', 1);

SET FOREIGN_KEY_CHECKS = 1;
